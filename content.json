{"meta":{"title":"MoonIsAMute","subtitle":"","description":"堕天万国信使会梦到电子甜甜圈吗","author":"m0st1ma","url":"http://example.com","root":"/"},"pages":[{"title":"archives","date":"2025-10-08T09:20:18.000Z","updated":"2025-10-08T09:20:18.824Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"友链","date":"2025-10-07T16:00:00.000Z","updated":"2025-10-08T09:24:42.359Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"目前暂无友链，敬请期待~"},{"title":"关于","date":"2025-10-07T16:00:00.000Z","updated":"2025-10-08T12:33:15.126Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"m0st1ma，拉特兰的莫斯提马本人，堕天的万国信使，目前 香港中文大学（深圳）数据科学学院 本科在读。 联系方式 邮箱：3493456287@qq.com GitHub：Arvin-Chaser"},{"title":"分类","date":"2025-10-08T10:45:32.835Z","updated":"2025-10-08T10:45:32.835Z","comments":true,"path":"/categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-10-08T10:38:46.449Z","updated":"2025-10-08T10:38:46.449Z","comments":true,"path":"/tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Optimization]Game Theory","slug":"gametheory","date":"2025-10-19T16:00:00.000Z","updated":"2025-10-19T16:13:59.193Z","comments":true,"path":"2025/10/20/gametheory/","permalink":"http://example.com/2025/10/20/gametheory/","excerpt":"","text":"博弈论初步，所分析的问题仅为简单的双人零和问题。 Matching Pennies Game 最简单的零和游戏：两个玩家各有一枚硬币，秘密的设定为向上或向下；同时揭露后，若相同则玩家A获得两枚硬币，不同则玩家B获得两枚硬币。 在描述双人零和问题时，我们通常引入如下状态变量： $S_1,…,S_m:$玩家A的策略 $T_1,…T_n:$玩家B的策略 玩家A的回报表格，如： $T_1$ … $T_j$ … $T_n$ $S_1$ $p_{11}$ … $p_{1j}$ … $p_{1n}$ … … … … … … $S_i$ $p_{i1}$ … $p_{ij}$ … $p_{in}$ … … … … … … $S_m$ $p_{m1}$ … $p_{mj}$ … $p_mn$ 同时，在博弈论中，我们具有一个重要的前提假设：两个玩家都是足够聪明，足够理性的。 回到Pennies Game，在分析游戏时，参考如上的表格，我们希望知道： 对于每个策略$S_i$，玩家A执行它的相应概率（比例）$x_i$ 对于每个策略$T_j$，玩家B执行它的相应概率（比例）$y_j$ 在这些$x,y$的运行下，A能最大化他的利润，B能最小化他的损失 这两个最优化问题的存在，是由如下逻辑推来： 玩家A知道玩家B会尽可能限制他的收入，因为他的收入就是B的损失，所以玩家A的策略应该是在B全力最小化A收入的情况下，尽可能最大化自己的收入，也就是maximize the minimum 而相应的，玩家B知道玩家A会尽可能最大化自己的收入，所以玩家B的策略应该是在A全力最大化其收入的情况下，尽可能最小化A的收入，也就是minimize the maximum Solution 1 of MPG：Eliminating Dominated Strategies 例： $T_1$ $T_2$ $T_3$ $S_1$ $1$ $2$ $4$ $S_2$ $1$ $0$ $5$ $S_3$ $0$ $1$ $-1$ 在该例中，玩家A永远不会执行策略$S_3$，因为$S_1$的每个解都优于$S_3$ 所以$S_3$ is dominated by $S_1$,因此我们将它eliminate，这就是solution 1 A strategy $S_i$ is dominated by strategy $S_j$ if $S_j$is at least as good as $S_i$ regardless of what the opponent does A dominated strategy can be eliminated Solution 2 of MPG: Identifying a Saddle Point 例： $T_1$ $T_2$ $T_3$ $min$ $S_1$ $-3$ $-2$ $4$ $-3$ $S_2$ $2$ $0$ $2$ $0$ $S_3$ $5$ $-2$ $-4$ $-4$ $max$ $5$ $0$ $4$ 先从玩家A分析：若执行策略$S_1$，那么因为玩家B足够聪明，所以玩家B会执行策略$T_1$，使得A损失最大；$S_2$和$S_3$同理 玩家B同理 于是我们有这样的结论：如果玩家A只能执行一种策略，那么他只会执行$S_2$， 玩家B只会执行$T_2$，因为在他们确定这两种策略的情况下，只要自己改变策略，那么对面的解一定会被优化 也就是说，在这个例子中，最优解是两个确定的策略，而不是带有概率的策略选择，这样的解我们称其为pure optimal strategy. 由于这个点附近的所有点都是比他更劣质的解，回顾多元积分中的定义，这恰是一个鞍点 注意： 鞍点并不一定存在 Solution 3 of MPG: Graphical Method $T_1$ $T_2$ $T_3$ $x$ $S_1$ $0$ $-2$ $2$ $1-x$ $S_2$ $5$ $4$ $-3$ $x$和$1-x$是对应策略的概率（占比） 我们考虑玩家A的策略： 若玩家B只执行策略$T_1$，那么玩家A获得$0x+5(1-x)$ 若玩家B只执行策略$T_2$，那么玩家A获得$-2x+4(1-x)$ 若玩家B只执行策略$T_3$，那么玩家A获得$2x-3(1-x)$ 所以玩家A需要最大化：$max$ $Z$ = $min${$5-5x, 4-6x, -3+5x$}，我们可以在$x-Z$坐标系中用图像法求解 但是只要存在两种以上的策略，该方法就失效 Solution 4 of MPG: LP 例： $T_1$ $T_2$ $x$ $S_1$ $3$ $-2$ $1-x$ $S_2$ $1$ $2$ 玩家A的最优化问题为：$max$ $Z$ = $min${$2x+1,-4x+2$}，回顾我们在最早研究LP时提到的对这种类型的转化方法，该问题等价为： $max$ $u$, subject to$u\\leq 2x+1$，$u\\leq -4x+2$ ，$0\\leq x\\leq1$ 同样的问题，我们不妨在从玩家B的角度来考虑，他的最优化问题为：$min$ $v$ = $max$ {$5y-2, -y+2$}，等价为： $min$ $v$, subject to $v\\geq 5y-2, v\\geq -y+2, 0\\leq y\\leq1$ 不妨比较两个LP，我们不难发现他们是互为Dual Problem的 回顾一般情况： $T_1$ … $T_j$ … $T_n$ $S_1$ $p_{11}$ … $p_{1j}$ … $p_{1n}$ … … … … … … $S_i$ $p_{i1}$ … $p_{ij}$ … $p_{in}$ … … … … … … $S_m$ $p_{m1}$ … $p_{mj}$ … $p_mn$ 玩家A: $max$ $u$, $u\\leq \\sum_{i=1}^{m} p_{ij}x_i,\\forall j = 1, …, n$ ，且 $\\sum_{i=1}^{m}x_i = 1, x_i\\geq 0, \\forall i = 1, …, m$ 玩家B: $min$ $v$, $v\\geq \\sum_{j=1}^{n} p_{ij}y_j,\\forall i = 1, …, m$ ，且 $\\sum_{j=1}^{n}y_j = 1, y_j\\geq 0, \\forall j = 1, …, n$ 根据Duality Theory，$u^=v^$ ，且 在玩家B保持$y^$的情况下，玩家A不能通过执行一个不同于$x^$的解来获得更优的$u$ 在玩家A保持$x^$的情况下，玩家B不能通过执行一个不不同于$y^$的解来获得一个更优的$v$ Nash Equilibrium： 当一组解$(x^,y^)$满足如下条件时，我们称它们为Nash Equilibrium： 对任何可行的$x$，解$(x,y^)$的回报不会优于解$(x^,y^*)$的回报 对任何可行的$y$，解$(x^,y)$的回报不会优于解$(x^,y^*)$的回报 注意： 所有的pure optimal strategy是一个Nash Equilibrium 所有的鞍点也是一个Nash Equilibrium Nash Equilibrium可能为mixed strategies","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"C++中的小技巧和对一些语法的辨析...","slug":"C++中的一些技巧","date":"2025-10-09T15:46:30.000Z","updated":"2025-10-13T11:22:07.865Z","comments":true,"path":"2025/10/09/C++中的一些技巧/","permalink":"http://example.com/2025/10/09/C++%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/","excerpt":"","text":"函数重载 C++中函数可以被重载，这意味着若两个函数函数名相同，但是参数的数量和类型不同，那么编译器能通过调用函数时输入的参数数量和类型来决定该调用哪个版本的函数。 例： 12void func(int a);void func(double b); 这两个函数就是合法的重载，在引用func(2)和func(3.14)时，编译器会调用不同的函数模块。 注意，若两个函数只有参数名不同，但参数数量和类型完全一致，那么就是不合法的重载，例： 12void func(int a);void func(int b); 该代码会编译错误。 函数重载在初始化一些不同类型的数据时会用到，提高代码的可读性。 函数中的可选参数 C++中，函数可以在声明参数时，对其进行可选化处理. 在声明时，只要写参数类型 参数名=默认值，就完成了可选化处理，如： 1void setMargin(int margin = 72); 这个函数在调用时可以传参：setMargin(100); 于是margin = 100 调用时也可以不传参：setMargin();，则该函数在执行时margin = 72，为默认值 也可以存在多参数的可选化，如void setInitialLocation(double x = 0, double y = 0)，则我们可以传x，传y，传x和y，或者一个都不传。 实际应用：我们可以与函数重载结合来实现对调用时参数数量的限定，如：void setPosition(double x = 0, double y = 0);若在调用时仅提供一个参数，那么它会被自动分配给x，因为y是可选参数，默认为0。 若我们想要将传入的参数数量限定为：要么两个，要么零个，我们可以这样重载函数： 1234void setPosition(double x, double y);void setPosition() &#123; setPosition(0, 0);&#125; 也就是，我们可以列出所有的情况，避免参数可选化可能导致的非法输入。 C++中的引用变量 引用变量： 当存在这样的声明时： 12int n1 = 1, n2 = 2;int &amp;x = n1, &amp;y = n2; 修改n1和x是一样的，修改n2和y是一样的。 对引用变量底层逻辑的解析：实际上，编译器会把x转换为类似int* const x = &amp;n1;的指针常量，x在内存中存储的实际上是n1的地址，在修改时实际上进行了对该地址取内容的操作。 但是，表现在用户面前的过程是类似于给n1起了一个别名n1，使得两个变量内容相同且互相影响，增强了可读性，使代码更加简洁。 例： 12345void swap(int &amp;x, int &amp;y) &#123; int tmp = x; x = y; y = tmp;&#125; 在调用了swap(a,b)后，a,b的值便会交换，因为在swap函数内修改x,y时，作为它们别名的a,b也会被修改。 C++中的自建库与接口 以报错函数为例： 123456789//File:error.h#ifndef _error_h#define _error_h//#include&lt;string.h&gt;//using namespace std;void error(std:: string msg);#endif 注意，#ifndef #define #endif是头文件的预处理指令，保证头文件在一次编译过程中，只会被读取并处理一次，避免重复包含导致的错误。 在头文件中，可以对系统库文件进行引用，如这里删去#include&lt;string&gt;中的注释是没有影响的，这里注释后仍能运行，是因为在调用该error.h的error.cpp中，引用了系统的string.h，也就是说：在源文件中已经得到包含的库文件，不必再在我们自己的头文件中再度include。 using namespace std：头文件中通常不会使用using namespace std!!，因为头文件在被其它源文件包含时，若用了using namespace std，会把std空间里的所有内容无差别引入，容易造成命名冲突，我们只在用到标准库类型时，打上标记：std::string 注意，在.h文件中，我们只需要对函数进行声明，具体实现的过程我们放在.cpp文件中。 如，我们继续完成error.cpp 12345678910//File:error.cpp#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string.h&gt;#include &quot;error.h&quot;using namespace std;void error(string msg) &#123; cerr &lt;&lt; msg &lt;&lt; endl; exit(EXIT_FAILURE);&#125; 实现文件(.cpp) 和接口头文件(.h) 一起构成一个完整的文件。 其它关键字和技巧： extern：可以将变量限定在当前文件中使用，不通过接口传递，如extern const double PI; 注意，可以在.h和.cpp中使用。 字符处理： &quot;a&quot;和'a'的区别：&quot;a&quot;是一个包含单字符'a'和一个终止符'\\0'的的字符串，即两元素的数组；'a'就是一个字符。 在对字符串调用sizeof时，返回的是所占的储存空间，而非字符串长度。 注意，在C++中可以cout &lt;&lt; s1 + s2;但是不可以cout &lt;&lt; &quot;Hello&quot; + &quot;World!&quot;; 因为字符串的+运算是在类里重载过的，而&quot;Hello&quot;和&quot;World!&quot;的实质其实是一个指针，不能进行加减运算。 例： 1234char name1[] = &quot;Ray&quot;;std::string name2 = &quot;Ray&quot;;std::cout &lt;&lt; &quot;Hello, &quot; + name1 &lt;&lt; std::endl;std::cout &lt;&lt; &quot;Hello, &quot; + name2 &lt;&lt; std::endl; 那么第一个输出语句会输出乱码，第二个会输出正常的拼接字符串，这体现了char数组和string的区别。 格式化输出： 12345678910111213141516#include&lt;iosteam&gt;#include&lt;iomanip&gt;using namespace std;const double PI = 314.159265358979323846;int main() &#123; cout &lt;&lt; fixed &lt;&lt; setprecision(20) &lt;&lt; PI &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; PI &lt;&lt; endl; cout &lt;&lt; scientific &lt;&lt; setprecision(15) &lt;&lt; PI &lt;&lt; endl; cout &lt;&lt; uppercase &lt;&lt; scientific &lt;&lt; setprecision(6) &lt;&lt; PI &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setw(16) &lt;&lt; setprecision(9) &lt;&lt; PI &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; PI &lt;&lt; endl; cout &lt;&lt; fixed &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; setw(10) &lt;&lt; setprecision(4) &lt;&lt; left &lt;&lt; PI &lt;&lt; endl; return 0;&#125; 结果为： 1234567314.15926535897932581065314.1592653.141592653589793e+023.141593E+02 314.15926535900314.1593314.159300 有一些都是近似值，计算机中对小数很难做到完全一致。 get函数： get函数在系统库中是重载过的，会随我们传入参数的类型变化而变化： 1234int ch;while((ch = get()) != EOF) &#123; &#125; 参数为int的get是将下一个字符按int类型读入，输入终止时get会返回EOF 1234chat chwhile(get(ch)) &#123; &#125; 参数为char的get是将下一个字符按char类型读入，输入终止时会返回一个类似false的信号，可以作为逻辑语句来判断。 Enumerated types（枚举类型）： 枚举类型类似若干个int类型组成的集合，但每个int值都有其独特的名字，如：enum Direction { North, East, South, West }; 编译器会默认从0开始依次赋值，如上例中North为0，以此类推。 也可以自己手动初始化枚举值： 12345678enum Coin &#123; penny = 1, nickel = 5, dime = 10, quarter = 25, half_dollar = 50, dollar = 100&#125;; 结构体： 普通的结构体不再赘述，仅列例子： 12345struct Point &#123; int x; int y;&#125;;Point pt; 在结构体中，可以重载运算符、定义构造函数、成员函数等： 12345678910111213141516171819202122232425262728293031323334353637struct Point &#123; int x, y; Point():x(0), y(0)&#123;&#125;; Point(int xx, int yy):x(xx), y(yy)&#123;&#125;; Point &amp;operator+(const Point pt); double length(const Point &amp;p); double length(); string toString(); ~Point()&#123;&#125;;&#125;Point &amp;Point::operator+(const Point pt) &#123; this-&gt;x += pt.x; this-&gt;y += pt.y; return *this;&#125;double Point::length(const Point &amp;p) &#123; double dx = p.x - this-&gt;x; double dy = p.y - this-&gt;y; return sqrt(dx * dx + dy * dy);&#125;double Point::length() &#123; double dx = this-&gt;x; double dy = this-&gt;y; return sqrt(dx * dx + dy * dy);&#125;string Point::toString() &#123; ostringstream os; os &lt;&lt; &quot;(x, y, length) = (&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;length() &lt;&lt; &quot;)&quot;; return os.str();&#125; 注：形如Point(int xx, int yy):x(xx),y(yy){};的形式在初始化列表中就将x和y赋值，比在构造函数体内赋值更高效。 注：重载运算符时，this指向的是该运算符前的变量，如调用p1 + p2时，this指向p1。 类（Class）： 普通的类不再赘述，同样以Point类型为例： 123456class Point &#123;public: int x; int y;&#125;;Point pt; 调用方式同样是pt.x和pt.y。 但是这种方式使得x和y不被封装，通常我们将变量封装，使用public的函数来调用变量。 1234567class Point &#123;public : // protypes of publec methods to access x and yprivate : int x; int y;&#125;; 注意，若我们不重载=运算符或自建cpy函数，C++默认的复制运算只会复制对象的表层，如int double这些类型，若原对象中有动态分配的内存，那么拷贝对象会和原对象共享这一部分内存，一个释放，另一个也崩溃。 回顾可选参数，我们可以在初始化类变量时应用它们： 1Point(int xc = 0, int yc = 0) : x(xc), y(yc) &#123;&#125; Polymorphism（多态）： 多态意味着用同一个接口或符号，处理不同类型的东西。 重载就是多态的一种。 Templates（模板）： 满足我们用一套逻辑来对不同类型的数据类型进行同一处理的需求（如不同类型的swap等）。 声明形式：template&lt;typename type1, typename type2&gt; 如我们构建一个通用的swap模板： 123456template &lt;typename T&gt;void myswap(T &amp;a, T &amp;b) &#123; T temp = a; a = b; b = temp;&#125; 如上代码在我们调用myswap(int, int)和myswap(string, string)时都能完成正确的交换，因为对应的=运算符都是良好定义的。（注意：在这里的T相当于对我们输入参数的类型进行了读取，并在定义temp时发挥作用）。 在运算符并没有implemented的情况下，如：max('A','Z');（依赖于&gt;而运行），编译器会报错。 Iterator（迭代器）： 对于常见的数组类结构，我们能简单的通过下标来对其每个元素进行一个一个的迭代、遍历，但对于我们自己定义的类或者结构体，并没有默认的迭代方式。 引入Iterator来处理这种情况： 123for (ctype::iterator it = c.begin(); it != c.end(); it++) &#123; ...Body of loop involving *it...&#125; 具体的，以vector为例： 123for (Vector&lt;int&gt;::iterator it = v.begin(); it &lt; v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"[Discrete Math]Modular Arithmetic","slug":"Discrete Math lec10-11","date":"2025-10-09T11:33:20.000Z","updated":"2025-10-19T16:23:40.109Z","comments":true,"path":"2025/10/09/Discrete Math lec10-11/","permalink":"http://example.com/2025/10/09/Discrete%20Math%20lec10-11/","excerpt":"","text":"最大公因数之后，下一部分是同余及其相关运算、证明。 Modular Arithmetic 1.Modular addition, multiplication Definition 1: Given an integer$n$,called the modulus，two integers $a,b$ are congruent modulo $n$ iff $n\\mid (a-b)$ $a\\equiv b(\\mod n)$ iff $n\\mid (a - b)$ Definition 2: A congruence class of $a$ modulo $b$ is： $[a]_b = {a + kb:k\\in Z}$ Lemma 1.1 If $a\\equiv c$ ($\\mod n$)，and $b\\equiv d(\\mod n)$,then $a+b\\equiv c+d(\\mod n)$ Lemma 1.2 If $a\\equiv c(\\mod n)$, and$b\\equiv d(\\mod n)$,then $ab\\equiv cd(\\mod n)$ 2.Applications 证明A number is divisible by 9 iff the sum of its digits is divisible by 9 由Lemma 1.2推广，我们令$a = b, c = d$，所以我们得到：If$a\\equiv c(\\mod n)$,then $a^n \\equiv c^n (\\mod n)$ 所以由$10 \\equiv 1 (\\mod 9)$，我们得$\\forall i, 10^i \\equiv 1^i (\\mod 9)$，$10^i \\equiv 1(\\mod 9)$，进一步的，$d_i10^i \\mod 9 \\equiv d_i \\mod 9$ 由此，有$n\\mod 9\\equiv (d_k10_k + d_{k-1}10^{k-1}+…+d_110+d_0)\\mod 9 \\equiv (d_k+d_{k-1}+…+d_1+d_0)\\mod 9$ ，也就 意味着A number is divisible by 9 iff the sum of its digits is divisible by 9 15 Puzzle： 考虑一个$4\\times 4$，用数字$1-15$和一个空格填充的表格： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 移动规则为：我们可以将与空格相邻的数字格移动到空白格中。 问题为：从上表出发，我们有可能能达到如下的表格吗： 1 2 3 4 5 6 7 8 9 10 11 12 13 15 14 在对经过变换后的结果进行证明时，我们常用如下的方法： 首先尝试得出在整个变换途中不变的性质 我们接着证明目标状态不符合该不变的性质 于是证明目标状态是不可达的 注：寻找该不变性质通常是最困难的部分 我们不妨用数对来表示不同的状态，如起始：$((1,2,3,…,14,15),(4,4))$，末状态：$((1,2,3,…,15,14),(4,4))$，$(4,4)$代表空格的位置 引入定义： Given a sequence, a pair is disordered if the first element is larger. Formally, given a sequence $(a_1,a_2,…,a_n)$, a pair$(i,j)$ is disordered if $i &lt; j$,but $a_i&gt;a_j$. 对于一个状态，我们定义$Parity$ 为(number of disordered pairs + $i$) $\\mod 2$ ，接下来我们证明从初始状态开始，每一步移动都不会改变$Parity$ Case 1:Horizontal move ? ? ? ? ? $a$ ? ? ? ? ? ? ? ? ? $\\Rightarrow$ ? ? ? ? ? $a$ ? ? ? ? ? ? ? ? ? 显然这种情况不会改变我们状态表示数对中的任何一个参数，任何一个位置，所以显然水平移动不改变$Parity$ Case 2:Vertical move ? ? ? ? ? $a$ $b_1$ $b_2$ $b_3$ ? ? ? ? ? ? $\\Rightarrow$ ? ? ? ? ? $b_1$ $b_2$ $b_3$ $a$ ? ? ? ? ? ? 首先，我们发现$i$会增加$1$ 接下来，我们分情况讨论在$a$位置改变后，逆序对数量的变化情况： 若$a$最大，则逆序对将减少$3$，$Parity$在前状态的基础上$-3-1$，仍然模$2$同余 若$a$第二大，则逆序对将减少$1$，$Parity$在前状态的基础上$-1-1$，仍然模$2$同余 若$a$第二小，则逆序对将增加$1$，$Parity$在前状态的基础上$+1-1$，仍然模$2$同余 若$a$最小，则逆序对将增加$3$，$Parity$在前状态的基础上$+3-1$，仍然模$2$同余 自下向上移动时同理 这也意味着，在若干步后的状态，$Parity$仍与初始$Parity$模$2$同余。 计算本题中的始末状态，我们发现它们的$Parity$模$2$不同余，也就意味着该状态是不可达的，证毕。 3.Multiplicative inverses 定义： The multiplicative inverse of $a \\not\\equiv 0 (\\mod n)$ is an integer $a’$ such that $a\\cdot a’ \\equiv 1(\\mod n)$ Claim 3.1：If integers $k,n$ are not coprime (that is, $gcd(k, n)\\geq 2$),then $k$ does not have a multiplicative inverse modulo $n$. Theorem 3.2: If $gcd(k, n) = 1$, then there exists $k’$ such that: $k\\cdot k’ \\equiv 1(\\mod n)$ where $k’$is an inverse of $k(\\mod n)$ 证明：由于$gcd(k, n) = 1$，所以$\\exists s, t, sk+tn = 1\\Rightarrow tn = 1-sk \\Rightarrow n\\mid 1-sk \\Rightarrow 1-sk \\equiv 0 (\\mod n) \\Rightarrow 1\\equiv sk(\\mod n)$，意味着$k’=s$就是我们所求的乘法逆元 Theorem 3.3: If there exists a $k’$ such that $k\\cdot k’ \\equiv 1 (\\mod n)$,then this $k’$ is unique modulo $n$. 证明：令$k_1,k_2$均为$k$模$n$的乘法逆元，则$kk_1 \\equiv kk_2 \\equiv 1(\\mod n) \\Rightarrow k(k_1-k_2) \\equiv 0(\\mod n) \\Rightarrow k_1k(k_1-k_2)\\equiv 0(\\mod n) \\Rightarrow 1\\cdot (k_1-k_2)\\equiv 0 (\\mod n)$，也就意味着$k_1=k_2$，乘法逆元是唯一的（若存在） Claim 3.4: If $i\\cdot k \\equiv j\\cdot k(\\mod n)$ and $gdc(k,n) = 1$, then $i\\equiv j(\\mod n)$ 注： 同余中的加法和乘法都类似等号，但是在涉及除法时要引入该声明中的$gcd$条件 4.Fermat’s Little Theorem, Wilson’s Theorem 我们首先从同余中的类除法出发： 若$p$为质数且$gcd(k, p) = 1$，则由Claim 3.4我们可知$k(\\mod p), 2k(\\mod p), …, (p-1)k(\\mod p)$ 均不相等：若$i \\not= j, i, j$为$1$到$p-1$的 的整数，$ki \\equiv kj (\\mod p)$，那么$i$必须等于$j$，与假设矛盾。 换句话说，这$p-1$个数是$1, 2, …, (p-1)$的一个排列 接下来引入Fermat’s Little Theorem: Let $p$ be prime and $gcd(k,p) = 1$, then $k^{p-1} \\equiv 1(\\mod p)$ 证明：$1\\cdot 2 … (p - 1) \\equiv (k \\mod p) \\cdot (2k \\mod p) … ((p - 1)k \\mod p)(\\mod p) \\equiv (k\\cdot 2k…(p-1)k) (\\mod p) \\equiv (k^{p-1})\\cdot 1\\cdot 2…(p - 1) (\\mod p)$ 两边约去，得$k^{p-1} \\equiv 1(\\mod p)$ Wilson’s Theorem $p$ is prime iff $(p-1)! \\equiv -1(\\mod p)$ 证明充分条件： 在连乘类的证明中，我们常使用乘法逆元来对已有的一些数进行消去，在本证明中，我们先讨论逆元是它们自身的情况：也就是$x_2 \\equiv 1 (\\mod p)\\Rightarrow (x-1)(x+1) \\equiv 0 (\\mod p)$，故在模$p$的情况下，$1$和$p-1$是它们自身的乘法逆元。 由我们在前文中提到的Claim 3.4推论，$(p-1)! \\equiv (p-1)(p-2)…3\\cdot 2\\cdot 1$ ，再由逆元，得$(p-1)!\\equiv (2\\cdot 2^{-1})\\cdot (3\\cdot3^{-1}) … (1)\\cdot(p-1) (\\mod p) \\equiv (p-1)(\\mod p) \\equiv -1(\\mod p)$，得证。 证明必要条件： 假设$p$是合数，则存在质数$q$使得$q\\mid p$，则$p$和$(p-1)!$都被$q$整除，又因为$(p-1)!\\equiv -1 (\\mod p)$，所以$(p-1)! \\equiv -1(\\mod q)\\Rightarrow0\\equiv-1(\\mod q)$，显然是不成立的，所以由反证法，我们证明了必要性。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"http://example.com/tags/Discrete-Math/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://example.com/tags/Number-Theory/"}]},{"title":"[Discrete Math]Greatest Common Divisors","slug":"Discrete Math lec 9&&10","date":"2025-10-09T05:26:15.000Z","updated":"2025-10-09T11:54:26.178Z","comments":true,"path":"2025/10/09/Discrete Math lec 9&&10/","permalink":"http://example.com/2025/10/09/Discrete%20Math%20lec%209&&10/","excerpt":"","text":"作为整个数论部分的起点，我们首先从最大公因数(Greatest Common Divisors,gcd)开始 Greatest Common Divisors Basic Definitions: For any non-zero $b$，$b$ is a divisor of $a$ iff there is an integer $k$ such that $a = kb$.Denoted as “$b\\mid a$”,or $b$ divides $a$ ，or $a$ is divided by $b$. For any non-zero $b$, $a$ is a multiple of $b$ iff there is an integer $k$ such that $a = kb$ $b$ is a divisor of $a$ iff a is a multiple of $b$ $c$ is a common divisor of $a$ and $b$ iff $c\\mid a$ and $c\\mid b$ We denote the greatest common divisor of $a$ and $b$ as $gcd(a,b)$. The Quotient-Remainder Theorem: $\\forall a,b,\\in Z: b＞0,$there are unique integers $q,r$,such that: $a = qb + r$ and $0\\leq r &lt; b$ $q$ is the quotient of $a,b$, and $r$ is the remainder of $a, b$ We also concludes: $r = a \\mod b$ note, floor function: $\\lfloor x \\rfloor$ is the greatest integer that is less than or equal to $x$. 注意，这就是数论的基础，对除数和余数的定义，以此为基础将衍生出众多讨论 Computing $gcd(a,b)$ Euclid观察到： $gcd(a,b) = gcd(b,r)$ 这里的$r$就是前文我们提到的余数(remainder) 不难注意到，每进行一次从$gcd(a,b)$到$gcd(b,r)$的转化，第二个数就变小一次，我们不妨假设在所有的$gcd$项中，前一项总是大于后一项，然后考虑，当$r=0$时，代表了什么情况呢？ 显然，当$r=0$时，代表$b \\mid a$ ，也就意味着$gcd(a,b) = b$ 那么，我们通过不断的寻找与当前的$gcd$等价的$gcd$，并且不断的减小$b$，就能求解$gcd(a,b)$，这正是Euclid’s GCD Algorithm（辗转相除法） 12345gcd(a,b) if(b == 0), return a; else find q,r, where(a = qb + r); return gcd(b,r); 对$gcd(a,b)=gcd(b,r)$的数学证明： case 1:$r = 0$ 此时 $a = qb$,所以$gcd(a,b) = b$；显然$gcd(a,b)=gcd(b,r)$ case 2:$r&gt;0$ 不妨设$d$是$b,r$的一个公因数 $\\Rightarrow$ $\\exists k_1,k_2, b = k_1 d$ and $r = k_2d$ $\\Rightarrow$ $a = qb + r = (qk_1+k_2)d$ $\\Rightarrow$ $d$ 也是 $a,b$的公因数 不妨设$d$是$a,b$的一个公因数$\\Rightarrow$ $a = k_3d,b = k_1d\\Rightarrow$ $r = a - qb = k_3d - qk_1d = (k+3-qk_1)d\\Rightarrow d$也是$b,r$的公因数 于是我们证明了$(a,b)$和$(b,r)$共用公因数，也就意味着$gcd(a,b) = gcd(b,r)$ Linear Combination Definition $d$ is an integer linear combination of $a$ and $b$ if $d = sa + tb$ for integers $s,t$. Denote$spc(a,b)$ as the smallest positive integer linear combination of $a,b.$ Theorem 1.1 $gcd(a,b) = spc(a,b)$ 我们不妨用一些例子验证： $52$ 和$44$的$gcd$是$4$，同时$4$也是$52$和$44$的$spc:6 \\times 52 + (-7)\\times 44 = 4$ 接下来考虑对该定理进行证明： 在数论中，当我们试图证明两个表达式/数相等时，若我们找不到一系列的连等关系，可以尝试证明：$1.a\\leq b$ $2.a\\geq b$ ，从而综合这两个式子证明$a=b$，在我们证明$gcd = spc$时，就是用的这种方法。 证明$gcd(a,b)\\leq spc(a,b)$ ，我们并没有直接的不等关系，于是我们通过整除中隐含的不等关系证明。由$gcd$的定义可知，$gcd(a,b)\\mid a$且$gcd(a,b) \\mid b$ ，又因为$spc(a,b)$是$a,b$的一个linear combination，也就是说$\\exists s,t, spc(a,b) = sa + tb$,假设$a = k_1\\times gcd, b = k_2\\times gcd$ ，那么$spc(a,b) = (sk_1+tk_2)\\times gcd\\Rightarrow gcd \\mid spc \\Rightarrow gcd(a,b)\\leq spc(a,b)$，得证。 接下来我们证明$gcd(a,b)\\geq spc(a,b)$. 在证明这个不等式时，我们不妨从$gcd$的定义中入手：$gcd$是所有divisors中最大的那一个，也就是说，如果我们能证明$spc(a,b)$是$(a,b)$的一个divisor，那么就天然的有，$gcd(a,b)\\geq spc(a,b)$ 证明$spc(a,b) \\mid a$：由Quotient-Remainder Theorem 我们有： $a = q\\times spc(a,b) + r$ $spc(a,b) &gt; r \\geq 0$ 令$spc(a,b) = sa + tb$，那么$r = a - q\\times spc(a,b) = a-q\\times(sa+tb) = (1-qs)a + tb$ ，$r$也是一个$a,b$的线性组合。 由于$spc(a,b)$是$(a,b)$最小的正线性组合，所以$r$必须为$0$，也就意味着$spc(a,b)\\mid a$ 同理可证明$spc(a,b) \\mid b$ 于是我们可以宣称：$spc(a,b)\\leq gcd(a,b)$，与前面的证明相结合，我们证明出了$gcd(a,b) = spc(a,b)$ Theorem 1.1的应用 引理 1.2： 若$gcd(a,b) = 1$，且$gcd(a,c) = 1$，那么$gcd(a,bc) = 1$ 证明： 根据Theorem 1.1，$\\exists s,t,u,v$，使得： $sa+tb = 1$ $ua+vc = 1$ 故$(sa+tb)(ua+vc) = 1$ 展开可得：$saua + savc + tbua + tbvc = 1$ $\\Rightarrow (sau + svc + tbu)a + (tv)bc = 1$ 比对形式，我们发现这意味着$spc(a,bc) = 1$，所以$gcd(a,bc) = 1$ 在证明$gcd$相关的问题时，我们可以通过Theorem 1.1将其转化为线性组合的问题来求解 引理 1.3 若$p$是质数且$p\\mid ab$，那么$p\\mid a$或者$p\\mid b$（或者同时满足） 证明： 不妨假定$p\\nmid a$ ，则$gcd(p,a) = 1.$ 所以根据Theorem 1.1，$\\exists s,t$，满足： $sa+tp = 1$ $(sa)b+(tp)b=b$ 由于$p\\mid ab$，所以$ab = kp \\Rightarrow (sa)b = (sk)p \\Rightarrow (sk + tb)p = b \\Rightarrow p \\mid b$， 同理，当我们假定$p\\nmid b$时，我们可以依此方法得到$p\\mid a$ 于是引理得证。 引理 1.4 若$p$是质数，且$p\\mid a_1a_2…a_m$，那么对于一些$1\\leq i \\leq m$，$p\\mid a_i$ Fundamental Theorem of Arithmetic： 每个大于$1$的整数$n$，都存在唯一的质因数分解：$p_0\\leq p_1\\leq … \\leq p_k$，使得$n = p_0p_1…p_k$ 例：$61394323221 = 3\\cdot 3\\cdot 3\\cdot 7 \\cdot 11 \\cdot 11\\cdot 37\\cdot 37\\cdot 37\\cdot 53$ Proof by contradiction： 假设存在有至少两种质因数分解方式的数： 根据well-ordering principle，我们选择这些数中最小的那一个，称其为$n$：$n = p_1p_2…p_k = q_1q_2…q_m$ 由于$n$是这些数中最小的一个，所以我们必定有$\\forall i,j, p_i\\neq q_j$ （若存在$p_i=q_j$，那么我们可以在两侧同时约去公因数，也就意味着存在一个比$n$更小的，有至少两种质因数分解方式的数，这与我们的假定相悖） 又因为$p_1\\mid n = q_1q_2…q_m$，所以根据引理1.4，我们知$\\exists i,p_i \\mid q_i$. 再因为$p_1$和$q_i$都是质数，所以我们必有$p_1 = q_i$，产生矛盾 于是我们通过反证法证明了所有数都只有一种质因数分解方式。 Water Jug Problem： There are 2 jugs. One holds 5-gallons, and the other holds 3-gallons. The goal is to fill one of the jugs with exactly 4 gallons using only the two jugs. 正确方案如下： 对于规模较小的数据我们可以尝试手动模拟，但如果是规模较大的数据呢？ 不难发现，如果我们有两个容量分别为$B$和$L$的容器，那么每个容器内的水量总是一个$B$和$L$的线性组合。 又因为，$gcd(a,b) \\mid all$ $LC$，所以每个容器里的水量都是$gcd(a,b)$的一个倍数 所以我们得到了一般化的判断方法： 给出两个容量分别为$a$和$b$的容器($a\\leq b$)，我们可能在一个容器中恰好保有$k\\leq b$加仑的水，当且仅当$k$是$gcd(a,b)$的一个倍数。 进一步的，我们可以依据我们每次倒出$gcd(a,b)$的过程，来得到我们整个倒出$k$加仑水的过程： 得到$k = sa + tb$的解（注，此处用线性组合表示$gcd$后，乘若干倍即可） 重复$s$次如下过程： 装满$a$加仑的容器 将所有$a$加仑容器里的水倒入$b$加仑容器中。每当$b$加仑容器变满时，将其清空。 在整个过程中，$b$加仑容器将会被清空$t$次。 该过程结束后，$b$加仑容器中将恰有$k$加仑水。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"http://example.com/tags/Discrete-Math/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://example.com/tags/Number-Theory/"}]},{"title":"[Optimization]Sensitivity Analysis","slug":"optimizationsensitivity-analysis","date":"2025-09-29T06:47:06.000Z","updated":"2025-10-08T12:49:41.600Z","comments":true,"path":"2025/09/29/optimizationsensitivity-analysis/","permalink":"http://example.com/2025/09/29/optimizationsensitivity-analysis/","excerpt":"","text":"在研究LP时，我们时常会考虑这种问题： 当参数$(A,b,c)$改变时，最优解和最优值会如何变化？ 这种问题，我们称其为Sensitivity Analysis Local Sensitivity 考虑一个标准形式的LP: maximize $c^Tx$ s.t. $Ax=b$ $x≥0$ 我们将相应的最优值定为$V$ 当$A$和$c$固定时 当$A$和$c$固定时，$V$可被看作一个关于$b$的方程：$V(b)$ Theorem: Differentiability of $V(b)$ 若该问题的dual problem存在唯一的最优解$y^$，那么$\\nabla _bV(b) = y^$（注：该处的$\\nabla _b$是在微积分中提及过的概念，作为梯度向量，其每个分量为$V$对$b$各分量的偏导，即$i^{th} \\nabla _b V(b) = \\frac{\\delta V}{\\delta b_i}$；在该案例中，通俗的说，$\\nabla _bV(b)$描述了$b$的微小变化会如何影响最优值$V(b)$） 若dual optimal solution不唯一（或un bdd.或不可行），那么梯度向量就不是完备定义的 若$b_i$改变了一个微小量$\\Delta b_i$，那么objective value改变的微小量则是$\\Delta b_i y_i^*$ 证明： 由于primal problem的最优值$V$同样也是dual problem的最优值，所以对$V$的求解也可重写为： maximize $b^Ty$；s.t. $A^Ty ≤ c$，代入$y^$可知：$V(b) = b^Ty^$ 写成这种类似线性的形式后，便可以直观体现，若$b$改变了一个微小量$\\Delta b$，且最优解($y^$)不变，那么$V$的变化量为$\\Delta b^Ty^$ 注意，最优解的不变性在dual problem中得到体现，与下文中我们证明primal opt sol不变的过程相似 当$A$和$b$固定时 此时$V$可被看作一个关于$c$的方程 Theorem: Differentiability of $V©$ 若原问题存在唯一的最优解$x^$，那么$\\nabla _c V© = x^$ 证明，$V© = c^Tx$，当$A$和$b$确定时，解不变($x^* = A^{-1}b$)，所以当$c$变化一个微小量$\\Delta c$时，$V$的改变量必为$\\nabla c^Tx^*$ 当约束条件变为不等关系时 先前的结论仍然成立，为证明这一点我们可以引入松弛变量后再将其转化为标准形式，之后沿用上面的分析过程 样例： Global Sensitivity 首先讨论，在如下变量发生变动时，最优值会如何变化： 1.$b$变化为$b+\\Delta b$ 2.$c$变化为$c+\\Delta c$ 回顾单纯形法中的表格： $c^T - c_B^TA_B^{-1}A$ $-c_B^TA_B^{-1}b$ $A_B^{-1}A$ $A_B^{-1}b$ 当最后迭代到最优解时： reduced costs满足$c^T-c_B^TA_B^{-1}A≥0$ $x_B = A_B^{-1}b$是primal opt sol的含基部分，而$y=({A_B^{-1}})^Tc_B$则是dual opt sol 在$b$变化的情况下，最优值受到的影响 假设$b$变为了$\\tilde b = b + \\Delta b$，设原基为$B$，我们仍有：$\\overline c = c^T - c_B^TA_B^{-1}A ≥0$，因为reduced cost是不随$b$的改变而改变的 在变动后，为了讨论最优值受到的影响，基是否变化显然是我们关心的内容： 若我们想保证原来的基$B$对于新的问题仍是最优解，我们只需要验证新的基是否可行（因为最优性已由$\\overline c &gt;0$保证，我们只需要证明新的基仍可行，就可证明它仍是一组最优基）：若$\\tilde x_B = A_B^{-1}\\tilde b = A_B^{-1}(b+\\Delta b) = x_B^* + A_B^{-1}\\Delta b ≥ 0$，那么$B$仍然是新问题的一组最优基 则新的最优解为$\\tilde x = [\\tilde x_B; 0]$，新的最优值为$V(\\tilde b) = \\tilde b^T y^* = (b+\\Delta b)^Ty^* = V^* + (y^*)^T\\Delta b$ 同时在这种情况下，$y^* = (A_B^{-1})^Tc_B$仍是dual problem的最优解 于是我们有结论：若原最优基在变换后的问题中仍是最优基，那么local sensitivity便成立（参考前文） 接下来我们讨论，当$b$中只有一个变量发生改变时： 变化量在什么范围内，能够保证原最优基在变换后仍是最优基？ 令$\\Delta b = \\lambda e_i$，即$\\Delta b_i = \\lambda.$于是，我们需要满足： $x_B^* + \\lambda A_B^{-1}e_i ≥ 0$（通过该不等式我们可以解得$\\lambda $的范围） 求解$\\lambda$范围的例子： 在$c$变化的情况下，最优值受到的影响 假设$c$变为了$\\tilde c = c+\\Delta c$ 首先，沿用我们上面的分析，若$\\tilde c^T - \\tilde c_B^TA_B^{-1}A≥0$，那么$B$仍然是最优基 那么原最优解$x^*$也仍为一个最优解 对$\\tilde c^T - \\tilde c_B^TA_B^{-1}A≥0$进行进一步分析： 新的reduced costs可分为[基变量部分，非基变量部分] 基变量部分$=\\tilde c_B^T - \\tilde c_B^TA_B^{-1}A_B = \\tilde c_B^T - \\tilde c_B^T I = 0$，故基变量部分的reduced cost恒为$0$ 非基变量部分$=\\tilde c_N^T - \\tilde c_B^TA_B^{-1}A_N$，该部分必须非负 于是我们令$\\Delta c = \\lambda e_j$，接下来讨论两种情况：$j\\in B$和$j\\in N$ Case $1:j\\in B$ 在这种情况下，reduced cost$=c_N^T - (c_B^T + \\lambda e_j^T)A_B^{-1}A_N = c_N^T - c_B^TA_B^{-1}A_N - \\lambda e_j^TA_B^{-1}A_N$ 注意到$c_N^T - c_B^TA_B^{-1}A_N$是原问题的reduced cost，我们将其写为$r_N^T$ 则，为保证当前基仍为最优基，我们需要满足： $r_N^T - \\lambda e_j^TA_B^{-1}A_N ≥ 0$，我们可依据此不等式解出$\\lambda$的范围 Case $2:j\\in N$ 该情况中，reduced costs$=c_N^T + \\lambda e_j^T - c_B^TA_B^{-1}A_N = r_N^T + \\lambda e_j^T$ 于是解该不等式我们可得$\\lambda$范围：$r_N+\\lambda e_j ≥ 0$ 例 在$A$变化的情况下，最优值受到的影响 $c^T - c_B^TA_B^{-1}A$ $-c_B^TA_B^{-1}b$ $A_B^{-1}A$ $A_B^{-1}b$ 若变化发生在一个非基列中，假设为$A_j$，那么原最优解仍是可行的(non-basic $x_j$为$0$，该变化没有影响) 这种情况下，唯二的变化发生在$A_B^{-1}A$的第$j$列，和reduced cost$\\overline c_j$的第$j$列中 重新计算$\\overline c_j$，若它仍非负，那么原最优解仍是最优解；否则，依次更新单纯形法表格的第$j$列和reduced costs的第$j$列，以此为起点完成新的单纯形法 若变化发生在一个基列中，那么基本上所有的变量都会受到影响，我们不能简单地得到所有变化的量及其范围，一般从头进行一次新的单纯形法，得到结果后一一对比 其它变化 添加一个变量 若令新变量为$0$，则可令它为一个non-basic variable，那么原BFS仍是一个BFS，与原BFS相关的reduced costs没有变化 我们只需要检验和新变量有关联的reduced costs 若它非负，则原最优解加上新变量仍是最优解 若它为负，从此处开始新一轮的单纯形法 添加一个约束条件 若原最优解满足该约束条件，则原最优解仍是最优解 若不是，则我们用一个dual variable来表示这个新的约束条件，然后以此为起点，对dual problem进行新一轮的单纯形法运算","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]Simplex, Interior Point Method","slug":"optimizationsimplex-interior-point-method","date":"2025-09-29T06:46:36.000Z","updated":"2025-10-08T12:49:58.161Z","comments":true,"path":"2025/09/29/optimizationsimplex-interior-point-method/","permalink":"http://example.com/2025/09/29/optimizationsimplex-interior-point-method/","excerpt":"","text":"Simplex Method form the Perspective of Complementary Consitions 在上一节中我们完善了Duality Theorem的内容，其中我们通过Complementary Conditions提供了一个新的判断当前解是否最优的方法，那么该方法显然是可以在Simplex Method中得到进一步运用的。 我们不妨从Terminating tableau开始考量，在最优解对应的Tableau中： Basic Var. $Z$ Original Variables Slack Variables $RHS$ $Z$ ⭕ Constraint $1$ … Constraint $m$ Shadow Prices是直接以$Z$行，Slack Variabes列，也就是它们的系数这一形式出现的，更进一步的说，Dual optimal solutions是在这里出现的 那么，最优解的表格中我们能直接得到Shadow Prices的值，那么在先前的迭代过程中，⭕处的数值，又体现了当前解的什么性质呢？ 不妨回顾一个以Tabular Form进行的Simplex Method例子： 我们列出所有Complementary slackness conditions，并计算出每次迭代表格所对应的$\\overline{y_i}$，如下： 则每次Simplex Method迭代后，$s_1，s_2$这两列的数值正是在Dual Problem中一个能得到与当前$x$相同Objective Value的伪解（这个解仅仅满足和$x$Objective Value相同，不满足Dual Problem中所有的约束条件） 在Terminating Tableau中，这两个数值不再是伪解，而是最优解，因为此时$x,y$的Objective Value相等，正体现了它们为各自问题的最优解 Simplex:Complementary Solutions Property： 在每次迭代时，单纯形法会同时找到一个primal 可行解$x$和一个解$y$，使得这两个解满足complementary slackness conditions 若同时，$y$也是dual LP的可行解，那么根据complementary slackness property，此时的$x$和$y$恰为各自问题的最优解 于是我们从Complementary dual solutions的角度，可以对Simplex Method做这样的解读： 从一个primal可行解开始，不断迭代直到当前primal可行解对应的complementary dual解成为可行解 如果我们将这个过程反过来呢？ Dual Simplex Method 起始表格应满足： 所有$Z$行的元素都是非负的 每行对应的等式应当是：仅包含一个basic var.，且该basic var.的系数是$1$ 迭代过程： 确定leaving var.：选择RHS最负的行 确定entering var.： 若pivot row中的元素为负，则用$Z$行中的元素除以该元素，再取绝对值 取绝对值最小的一列为pivot column 所有行通过减去pivot row的若干倍，消去pivot column中的元素 结束条件：（不同于Optimality Test，这里使用Feasibility Test） 若所有$RHS$非负，停下（注意，不包括$Z$行的$RHS$） 此时表中的BFS即为最优解 例： 在这种思想启发下的Simplex Method，初始化过程也与普通的Simplex Method不一样，该方法的初始化： 将原LP转化为标准形式 找到一个basic solution，使得$Z$的表达式中没有basic variables，且所有系数均非负（注意，该basic solution不一定是可行解） 将约束式重写为所有变量在$LHS$的形式 该方法对LP的dual problem进行操作，从一个dual 可行解开始，最终得到一对均可行且满足complementary conditions的解，即该问题与其dual Problem的一对最优解 The Interior Point Method (simple intro.) 我们再次列出LP的所有Optimality Conditions： 1.Primal Feasibility：$Ax=b, x≥0$ 2.Dual Feasibility：$A^Ty≤c$ 3.Complementarity：$x_i\\cdot s_i = x_i\\cdot (c_i-A_i^Ty)=0, \\forall i$ Interior Point Method在确保$1$和$2$均满足的情况下，寻找到一对满足complementarity conditions的解 不妨用代数形式表达出整个问题： 我们想寻找到满足如下条件 $x,y,s$： $Ax=b, x≥0$ $A^Ty + s = c, s≥0$ $x_i\\cdot s_i = 0, \\forall i.$ 直接解决这个问题显然是不现实的，我们先尝试考虑一个松弛后的问题： $Ax=b, x≥0$ $A^Ty + s = c, s≥0$ $x_i\\cdot s_i ≤ \\mu , \\forall i，\\mu &gt; 0$ 我们称$\\mu$为complementarity gap 核心思路：若我们已经找到了一个拥有参数$\\mu _i$的解，我们期望凭此找到一个具有参数$\\mu _j$，且$\\mu _j &lt; \\mu _i$的解，从而一步步减小$\\mu$，直到$\\mu _n= 0$时，求得LP的解 Interior Point Method的核心步骤是证明，我们能从一个已知$\\mu $的解，迭代到一个$\\mu$更小的解 我们不妨从&quot;Interior Point Method&quot;这一名字开始入手。 在单纯形法中，我们只沿着各个极点搜索，也就是在多边形（体）的边上移动 在内点法中： 我们从可行域的内部开始 在我们到达最优解前，我们都保证$x&gt;0 and s&gt;0$ 注意：由内点法得到的最优解可能不是一个BFS（若解是唯一的，那么它是BFS） 解释：由内点法不断而得到的最优解，在LP退化的情况下，可能落在两个最优解的连线上，不是极点，自然也不是BFS 为了找到一个出发点，我们一般通过求解一个称作homogeneous self-dual problem的辅助问题来得到 内点法种类繁多，下文中介绍的是primal-dual type of interior point method 其它内点法的大致思路是相同的，不同之处在于迭代的方法 与单纯形法相比，内点法的复杂度较为稳定，不因问题的特化性而出现较大的差别；而单纯形法在一些类型的问题中复杂度较低，在特化的问题中复杂度较高，不够稳定 内点法的性质：内点法总是倾向于寻找一个最多非零元素的解，使得解的秩最大化","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]LP Duality Theory(Algebraic Form)","slug":"optimizationlp-duality-theorycont","date":"2025-09-29T01:01:19.000Z","updated":"2025-10-08T12:49:31.183Z","comments":true,"path":"2025/09/29/optimizationlp-duality-theorycont/","permalink":"http://example.com/2025/09/29/optimizationlp-duality-theorycont/","excerpt":"","text":"在上一节中我们通过一个例子大概阐述了Primal LP与Dual LP的关系，本节中我们首先用更代数化的形式重写该过程。 Duality of Standard Form 给出一个标准形式的LP（$m$个约束条件，$n$个变量） minimize $c^Tx$ subject to $Ax=b$ $x≥0$ 我们可以将其重写为： minimize $c^Tx + max y^T(b-Ax)$，$y\\in R^m$ subject to $x≥0$ 注意，通过在$min$里引入$max y^T(b-Ax)$，我们隐含了$Ax=b$的条件——若$Ax=b$不得到满足，那么该最小化问题无法求解，因为其中的$max$可到达$inf$ 接下来，我们假定$max$和$min$可以交换，那么此问题变为： $max$ $b^Ty + min$ $x^T (c - A^Ty)$，其中$x≥0$ 注意，我们和前文相同，在这里优先分析$min$的正负： 当$A^Ty≤c$时，$min$为0 当$A^Ty$不满足恒$≤c$时，$min$为$-inf$ 所以为了使$max$问题有解，添加约束：$A^Ty≤c$ 原问题变换为： maximize $b^Ty$ subject to$A^Ty≤c$ 这样的两个LP，我们就称它们是dual to each other的；若其中一个被我们定为Primal problem，那么另外一个就是Dual problem 对于第一个最小化问题来说，$y$称为dual variables 两个问题的最优值相等 Different Duality Forms 我们将尝试推导一些非标准形式的二元性质 Problem 1 minimize $c^Tx$ subject to $Ax≥b$ 同理，该方程可重写为：$min$ $c^Tx + max$ $y^T(b-Ax)$，$y≥0$ 与前文相同，这里对$y^T(b-Ax)$求$max$的行为和该问题的有解性一起，保证了$Ax≥b$的约束条件成立 我们再次复刻先前的操作，交换$max$和$min$，得到 $max$ $b^Ty + min$ $x^T(c-A^Ty)$ ，$y≥0$ 进一步的，该方程等价于 maximize $b^Ty$ subject to $A^Ty=c$ $y≥0$ 注意：此处的约束条件是$A^Ty=c$，而非不等关系，这是因为系数$x^T$没有规定正负，只要$A^Ty$和$c$不相等就会出现原问题无解的情况；对比之下，Primal Problem中我们提供的是不等式，是因为我们存在$y≥0$的约束条件 给出一些常见的Dual Problems： 这里提到的&quot;Equality constraints always correspond to free variables&quot;，正是我们前文中所分析的，变量正负对约束条件是等式还是不等式形式存在影响的结果。 例： minimize $x_1+2x_2$ subject to$x_1+x_2≥5$ $x_1-x_2≤3$ $x_1≥0, x_2\\in R$(free) 总结出表格如下： Primal minimize maximize Dual constraints $≥b_i \\ ≤b_i \\ =b_i$ $≥0 \\ ≤0 \\ free$ variables variables $≥0 \\ ≤0 \\ free$ $≤c_j \\ ≥ c_j \\ =c_j$ constraints Primal constraints($m$) $\\Rrightarrow$ dual variables($m$) Primal variables($m$) $\\Rrightarrow$ dual constrains($n$) Duality Theory Weak Duality Theorem 回想上一节中我们对Primal LP和Dual LP函数值大小关系的辨析： 假设Primal LP的objective function是$max$ $c_1x_1+…+c_nx_n$，$(\\overline x_1, … \\overline x_n)$是一个BFS 假设Dual LP的objective function是$min$ $b_1y_1+…+b_my_m$，$(\\overline y_1, … \\overline y_m)$是一个BFS 那么 $c_1\\overline x_1 + … + c_n\\overline x_n ≤ b_1\\overline y_1 + … + b_m\\overline y_m$ Strong Duality Theorem 与weak duality theorem唯一的不同就是引入了两个确定的最优值： 令$(x_1^, … ,x_m^)$为primal LP的最优解 令$(y_1^, … , y_m^)$为dual LP的最优解 那么$c_1\\overline x_1 + … + c_n\\overline x_n ≤ c_1x_1^* + … + c_nx_n^* = b_1y_1^* + … + b_my_m^* ≤ b_1\\overline y_1 + … + b_m\\overline y_m$ 也就意味着：若一个primal 可行解和一个dual 可行解有着相同的函数值，那么它们分别为各自问题的最优解。 Algebraic Version Primal Dual $min$ $c^Tx \\ s.t. Ax=b, x≥0$ $max$ $b^Ty \\ s.t. A^Ty≤c$ Weak Duality Theorem $b^Ty≤c^Tx$ 简易证明： $b^Ty = (Ax)^Ty = x^T(A^T)y≤c^Tx$ 注：我们在这里运用了$A^Ty≤c$进行推导 Optimality conditions in duality： 1.$x$ is primal feasible 2.$y$ is dual feasible The objective values coincide, $i.e.$ $c^Tx = b^Ty$ 这也意味着，解决一个LP（假设是标准形式），也就等价于求解如下的线性系统： $Ax=b$ $A^Ty≤c$ $b^Ty=c^Tx$ Strong Duality Theorem 若一个LP存在一个最优解，那么它的Dual LP也同样存在一个最优解，且这两个最优值相同。 Optimality &amp; Feasibility &amp; Boundedness Primal丨Dual Finite Optimum Unbounded Infeasible Finite Optimum √ Unbounded √ Infeasible √ √ Complementary Slackness Conditions 仍然从window-door example开始： Primal LP： $max$ $Z=3x_1+5x_2$ $x_1≤4$ $2x_2≤12$ $3x_1+2x_2≤18$ $x_1≥0,x_2≥0$ 最优解为$(x_1^,x_2^)$ Dual LP: $min$ $4y_1+12y_2+18y_3$ $y_1+3y_3≥3$ $2y_2+2y_3≥5$ $y_1,y_2,y_3≥0$ 最优解为$(y_1^,y_2^,y_3^*)$ 注意到： $y_1^(4-x_1^)≥0 \\ y_2^(12-2x_2^)≥0 \\ y_3^(18-3x_1^-2x_2^*)≥0$ $x_1^(y_1^+3y_3^-3)≥0 \\ x_2^(2y_2^+2y_3^-5)≥0$ $y_1^(4-x_1^) + y_2^(12-2x_2^)+y_3^(18-3x_1^-2x_2^) \\ + x_1^(y_1^+3y_3^-3) + x_2^(2y_2^+2y_3^-5) \\ = 4y_1^ + 12y_2^* + 18y_3^* - 3x_1^* - 5x_2^* = 0$(由最优解的最优值相同推导最后一步) 两者结合，可知： $y_1^(4-x_1^)=0$ $y_2^(12-2x_2^)=0$ $y_3^(18-3x_1^-2x_2^*)=0$ $x_1^(y_1^+3y_3^*-3)=0$ $x_2^(2y_2^+2y_3^*-5)=0$ 我们称这些等式为Complementary Slackness Conditions（$y_i$与第$i$个Primal constraint对应，$x_j$与第$j$个Dual constraint对应） 进一步的，我们能推导出：Primal(Dual)LP 最优解中的一个变量可为非负，仅当它在Dual(Primal)中对应的约束条件在最优解时，该约束条件不被松弛（约束变量为$0$，恰好到达约束条件，所以在$var.\\cdot constraint$时，$constraint$为0，使得$var.$可自由取值） 推广到一般情况，即： 我们还可总结出complementary slackness conditions与optimality的关系：满足complementary slackness conditions的可行解是最优解 Algebraic Version Primal Dual $min$ $c^Tx \\ s.t. Ax=b, x≥0$ $max$ $b^Ty \\ s.t. A^Ty≤c$ Theorem:Complementarity Conditions $x,y$是最优解，当且仅当：$x_i\\cdot (c_i-A_i^Ty) = 0, i = 1, …, n$ 以例检验： 证明： 若$x,y$分别为Primal和Dual LP的最优解，则我们有：$c^Tx=b^Ty$ 展开，得：$0=c^Tx-b^Ty=c^Tx-y^TAx=\\sum_{i=1}^n(c_i-A_i^Ty)\\cdot x_i$ 由于$c_i-A_i^Ty≥0$且$x_i≥0$，所以我们必有：$(c_i-A_i^Ty)\\cdot x_i = 0，\\forall i=1,…,n.$，得证 有时为了便于书写，我们将dual problem重写为： $max$ $b^Ty \\ s.t. A^Ty + s = c, s≥0$ 于是complementarity conditions可写为$x_i \\cdot s_i = 0, \\forall i = 1, …, n$ 整理如上叙述，得： Theorem: Complementarity Conditions 令$x,y$分别为primal和dual problem的可行解，则$x,y$是最优解，当且仅当：$y_i\\cdot (a_i^Tx - b_i) = 0, \\forall i$ and $x_j\\cdot (A_j^Ty - c_j) = 0, \\forall j.$","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]Shadow Price and LP Duality","slug":"optimizationshadow-price-and-lp-duality","date":"2025-09-28T07:02:51.000Z","updated":"2025-10-08T12:49:50.991Z","comments":true,"path":"2025/09/28/optimizationshadow-price-and-lp-duality/","permalink":"http://example.com/2025/09/28/optimizationshadow-price-and-lp-duality/","excerpt":"","text":"Shadow Prices …How valuable are the resources? 回顾window door example： door window total hours Plant 1(prepare door frame) 1 4 Plant 2(prepare window frame) 2 12 Plant 3(assembly) 3 2 18 Profit $3 $5 Question 1: What is the minimum price that you should offer to buy the entire operation? Question 2:What is the price that the company should be willing to pay for an extra working hour of plant 1, or 2, or 3? 这里的Q1正是之前用LP解决的问题，这里不再赘述 转化为stand form后，在最优解处：$Z=36 - \\frac{3}{2}s_2-s_3$，$s_2,s_3$为slack variables 问题二中，我们试图量化：在三个约束式的条件扩大一个单位量的情况下，原问题的最优解能再扩大多少 不妨回到原问题中求解： 若将约束条件$1$变为$x_1≤5$，我们得到新的最优值仍为$36$ 若将约束条件$2$变为$2x_2≤13$，我们得到新的最优值变为$\\frac{75}{2}$，增加了$\\frac{3}{2}$ 若将约束条件$3$变为$3x_1+2x_2≤18$，我们得到新的最优值变为$37$，增加了$1$ 我们将$(0, \\frac{3}{2}, 1)$称为这三个约束条件的shadow prices 注意到，最优解处，Objective Function恰好可以写为$Z = 36 - 0s_1-\\frac{3}{2}s_2 - s_3$，我们所引入的shadow prices正是Objective Function中slack variables的系数 根据这一联系，我们可以进一步的解释shadow prices的含义：当约束条件被松弛时，Objective value随之扩大（减小）的程度，一个约束条件对应一个shadow price 注意：一个最优解的表示形式中（用nonbasic variable表示），显然可能存在decision variable和slack variable的组合，在这种情况下，decision variable被我们忽略，因为一个constraint对应的是一个slack variable，也只有slack variable的系数才能体现与之对应的constraint在被松弛时Objective value扩大（减小）的程度 LP Duality 我们在如上的过程中，是假设约束条件被松弛，从而计算出shadow price，那么我们不妨抛开这种直接修改约束条件的方法，设三个约束条件的shadow prices分别为$y_1,y_2,y_3$；那么在$y_1,y_2,y_3$为decision variables的情况下，我们能否求出Q1的最优解？ door window total hours Plant 1(prepare door frame) 1 4 Plant 2(prepare window frame) 2 12 Plant 3(assembly) 3 2 18 Profit $3 $5 Q1:What is the minimum price that you should offer to buy the entire operation? 我们重设Q2为：What is the minimum price that you should offer to buy these three plants? 由此得到的两个LP分别为： LP1: max $Z = 3x_1 + 5x_2 \\ x_1 ≤ 4 \\ 2x_2≤12 \\ 3x_1+2x_2 ≤ 18 \\ x_1,x_2≥0$ LP2: min $M= 4y_1+12y_2+18y_3 \\ y_1 + 3y_3 ≥ 3 \\ 2y_2 + 2y_3 ≥ 5 \\ y_1,y_2,y_3≥0$ 若我们称LP1为Primal LP, 则LP2为the Dual of LP1 我们注意到，Primal LP中各约束条件的RHS是与Dual LP的Objective Function中$y_i$系数相同的$（4,12,18）$ 而Dual LP的约束条件中的各系数，则有如下的对应关系： 在Primal LP中$x_1$在约束条件$1$，约束条件$3$，和Objective Function中的系数分别为$1,3,3$，于是在Dual LP中我们有这样的约束条件：$y_1+3y_3≥3$ 同样的，$2y_2+2y_3≥5$也能在Primal LP中找到对应的系数 我们不妨试着再求Dual LP的Dual LP，不难求得，Dual LP的Dual LP，正是原来的Primal LP，这是它们的对称性质 分析Primal LP和Dual LP的变量、约束条件数和形式，我们发现： Primal LP有$n$个变量，$m$个约束条件，是一个最大化问题 与此同时，Dual LP有$m$个变量，$n$个约束条件，是一个最小化问题 更进一步的： Primal LP和Dual LP的最优值相同 Primal Constraints的shadow prices是Dual LP中各变量的最优解 Dual LP中的shadow prices是Primal LP总各变量的最优解 若一个Primal LP是最大值问题，那么它的任意一个可行解的值都小于等于其Dual LP的最优解（对最优值相同的进一步阐释）；对应的，若一个Primal LP是最小值问题，那么它的任意一个可行解的值都大于等于其Dual LP的最优解 关于两个LP Feasibility 和 Unbounded情况的关联（Duality Theorem） Case 1: 若Primal(Dual)LP 有可行解和一个Bounded Objective Value（也就意味着有最优解），那么 Dual（Primal）LP也存在最优解 Case 2:若Primal(Dual)LP 存在可行解，但是Objective Value是Unbounded，那么Dual(Primal)LP不存在可行解 Case 3:若Primal(Dual)LP不存在可行解，那么Dual(Primal)LP要么没有可行解，要么其Objective Value是unbounded的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]Simplex Tableau Method","slug":"optimizationsimplex-tableau-method","date":"2025-09-28T01:38:16.000Z","updated":"2025-10-08T12:50:05.716Z","comments":true,"path":"2025/09/28/optimizationsimplex-tableau-method/","permalink":"http://example.com/2025/09/28/optimizationsimplex-tableau-method/","excerpt":"","text":"注：Simplex Tableau Method的原理和过程与Simplex Method本质相同，Tableau Method是为了简化求解过程，方便我们选择entering和leaving variable，通过表格填充形式来优化判断过程的方法。 仍以window door question为例： Original LP: max $Z=3x_1+5x_2$ $x_1≤4$ $2x_2≤12$ $3x_1+2x_2≤18$ $x_1,x_2≥0$ Standard LP: min $-Z=-3x_1-5x_2$ $x_1+x_3=4$ $2x_2+x_4=12$ $3x_1+2x_2+x_5$=18 $x_1,x_2,x_3,x_4,x_5≥0$ Initialization: $Z-3x_1-5x_2=0$ $x_1+x_3=4$ $2x_2+x_4=12$ $3x_1+2x_2+x_5=18$ Basic var. $Z$ $x_1$ $x_2$ $x_3$ $x_4$ $x_5$ $RHS$ ratio $Z$ $1$ $-3$ $-5$ $0$ $0$ $0$ $0$ $x_3$ $0$ $1$ $0$ $1$ $0$ $0$ $4$ $x_4$ $0$ $0$ $2$ $0$ $1$ $0$ $12$ $\\frac{12}{2} = 6$ $x_5$ $0$ $3$ $2$ $0$ $0$ $1$ $18$ $\\frac{18}{2} = 9$ 注意：该表格中，$Z$是用non-basic variable表示的，我们凭此保证在$Z$行中，basic variable的系数为0，在每次迭代后，也要记得把$Z$转化为用新non-basic variable表示的形式。 复刻Simplex Method中的过程： - 1.选择entering variable：我们在$Z$的行中择出系数最小的non-basic variable - 2.考虑该non-basic variable所在的列，根据min-ratio test，求$RHS$和对应行系数的比值，取比值最小的一行 - 3.为保证形式的一致性，用leaving variable和non-basic variable来表示entering variable - 4.用3中的表达式来替代objective function和所有约束条件中的entering variable 该例中： 1.选择$x_2$为entering variable 2.选择$x_4$为leaving variable 3,4. - $x_3=4-x_1$ - $x_2=6 - 0.5x_4$ - $x_5=18-3x_1-2(6-0.5x_4)=6-3x_1+x_4$ - $Z=3x_1+5(6-0.5x_4)=30+3x_1-2.5x_4$ 接着对表格形式进行处理： | Basic var. | $Z$ | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $RHS$ | ratio | |------|------|------|------|------|------|------|------|------| | $Z$ | | $x_3$ | |$x_2$| |$x_5$| pivot row除以pivot number（即entering variable所在列和leaving variable所在行的交点） Basic var. $Z$ $x_1$ $x_2$ $x_3$ $x_4$ $x_5$ $RHS$ $Z$ $x_3$ $x_2$ $0$ $0$ $1$ $0$ $\\frac{1}{2}$ $0$ $\\frac{12}{2} = 6$ $x_5$ 对于其它每一列：减去用pivot row中的系数与新产生的entering variable一行相乘的结果，即该例中将有如下变换： $Row_1-(-5)×Row_3^{new}$ $Row_2-0×Row_3^{new}$ $Row_3^{new}$ -&gt; $Row_3/2$ $Row_4 - 2×Row_3^{new}$ 变换后： Basic var. $Z$ $x_1$ $x_2$ $x_3$ $x_4$ $x_5$ $RHS$ $Z$ $1$ $-3$ $0$ $0$ $\\frac{5}{2}$ $0$ $30$ $x_3$ $0$ $1$ $0$ $1$ $0$ $0$ $4$ $x_2$ $0$ $0$ $1$ $0$ $\\frac{1}{2}$ $0$ $6$ $x_5$ $0$ $3$ $0$ $0$ $-1$ $1$ $6$ 式子表现为： $Z-3x_1+\\frac{5}{2}x_4=30$ $x_1+x_3=4$ $x_2+\\frac{1}{2}x_4=6$ $3x_1-x_4+x_5=6$ 接着循环如上的迭代过程，我们即可得到最终解，若$Z$行中没有负系数的non-basic variable，也就意味着我们无法进一步优化$Z$的值，代表当前BFS即是最优解，而$Z$的Optimal Value数值上直接等于$RHS$，如下表中的36 Final Table: Basic var. $Z$ $x_1$ $x_2$ $x_3$ $x_4$ $x_5$ $RHS$ $Z$ $1$ $0$ $0$ $0$ $\\frac{3}{2}$ $1$ $36$ $x_3$ $0$ $0$ $0$ $1$ $\\frac{1}{3}$ $-\\frac{1}{3}$ $2$ $x_2$ $0$ $0$ $1$ $0$ $\\frac{1}{2}$ $0$ $6$ $x_1$ $0$ $1$ $0$ $0$ $-\\frac{1}{3}$ $\\frac{1}{3}$ $2$ 注意：该例的终结条件是no entering variable，对应着原问题达到最优解；若在确定entering variable后我们发现no leaving variable，则对应着原问题unbounded，是另一个终结条件，至此该方法的完备性得到体现。 不过在如上的迭代过程中，我们每次更新表格的过程都稍显冗杂：我们不仅要选择entering和leaving variable，每次更换non-basic variable后还要更新每个变量和Objective Function的表达形式，最后再依此改变表格的内容；我们期望找到更加便于计算和更新的一种方法。 Simplex Tableau 令$B$为当前的基，并给出基矩阵$A_B$和在Objective Function中这些基对应的系数$c_B$ Simplex Tableau是一个具有如下结构的矩阵： $c^T-c_B^TA_B^{-1}A$ $-c_B^TA_B^{-1}b$ $A_B^{-1}A$ $A_B^{-1}b$ 表格的下半部分可以看作是约束式的一种表达形式：$Ax=b$ to $A_B^{-1}Ax=A_B^{-1}b$ 不妨将$A$重写为$[A_B,A_N]$，则我们有： $A_B^{-1}A=[I,A_B^{-1}A_N]$，该模块必定含有一个单位矩阵 同样的，当前基为$B$时，我们将$x$重写为$[x_B,x_N]^T$，为满足$x$是可行解，我们有$A[x_B,x_N]^T=b$，由于non-basic variable均为0，所以可以解得$x=[A_B^{-1}b, 0]^T$ 所以右下角的模块代表了当前的BFS 对左上部分$c^T-c_B^TA_B^{-1}A$的分析： $\\overline{c} = c^T-c_B^TA_B^{-1}A = [c_B^T, c_N^T] - c_B^T[I, A_B^{-1}A_N]=[0, c_N^T-c_B^TA_B^{-1}A_N]$，正是reduced costs 对右上部分$-c_B^TA_B^{-1}b$的分析，$-c_B^TA_B^{-1}b=-c_B^Tx_b$，而Objective Function $Z = c_B^Tx_B + c_N^T 0 = c_B^T(A_B^{-1}b)$；也就是说右上部分是位于当前BFS时，Objective function值的相反数。 总结，该表格形式可写成： $0_m^T$, $c_N^T-c_B^TA_B^{-1}A_N$ $-c_B^Tx_B$ $I_m$, $A_B^{-1}A_N$ $x_B$ LP的这种形式称为canonical form canonical form 对应着一个BFS和它的相关数据 约束矩阵中与basic variables相对应的部分是一个单位矩阵 reduced costs部分中与basic variable相关的部分是$0$ 考虑判断当前BFS是否是最优解的条件，可知：若左上角的reduced costs部分均为非负，那么该BFS为最优解 为了将canonical form应用在Simplex method中，接下来是从一个canonical form迭代到另一个canonical form的过程： 以如下表为例 $B$ $-1$ $-2$ $0$ $0$ $0$ $0$ $3$ $1$ $0$ $1$ $0$ $0$ $100$ $4$ $0$ $2$ $0$ $1$ $0$ $200$ $5$ $1$ $1$ $0$ $0$ $1$ $150$ 1.选择entering index j 我们可选择任一reduced costs为负的index为entering index，本例中我们便可以选择$1$或$2$为entering index $j$（若应用Bland’s rule，我们便选择$1$） 2.比较$\\theta ^ *$并决定leaving index$B(l)$ 在该表中，我们可以很方便的求$\\frac{x_i}{\\overline{A_{ij}}}$（要大于$0$），即为最右侧的数值比该index下的元素值，如在本例中，若我们选择$1$为entering index，那么比值为$\\frac{100}{1}$和$\\frac{150}{1}$，我们选择较小的100，则我们得到leaving index$B(l)$为3 引入定义 ： entering column $j$ : the pivot column row $B(l)$: the pivot row The intersection element of the pivot column and the pivot row: pivot element 如在本例中，pivot column为$1$ pivot row为$3$ pivot element为$1$ 在我们确定了pivot column, pivot row, pivot element后，我们进入到迭代至下一个BFS的过程： 1.pivot row中的所有元素除以pivot element 2.所有行减去pivot row（变化后）乘以对应系数，以将该行中pivot column的元素消为$0$ 注意：所有运算都包括对最右侧一列的运算，同时最上面一行也要参与消去pivot column的运算 于是我们能得到一个新的canonical form表格，也就意味着我们迭代到了一个新的、更优的BFS 回顾我们选择entering index的时候不难发现，我们在保证解能得到优化的情况下，选择了较小的index而非优化程度最大的index，这是对small index rule的应用，根据收敛性保证了我们在有限步内能达到一个最优解/发现该LP unbounded 例： minimize $-10x_1-12x_2-12x_3$ $s.t.$ $x_1+2x_2+2x_3≤20$ $2x_1+x_2+2x_3≤20$ $2x_1+2x_2+x_3≤20$ $x_1,x_2,x_3≥0$ 首先，我们将其变换为标准形式： minimize $-10x_1-12x_2-12x_3$ $s.t. x_1+2x_2+2x_3+s_1=20$ $2x_1+x_2+2x_3+s_2=20$ $2x_1+2x_2+x_3+s_3=20$ $x_1,x_2,x_3,s_1,s_2,s_3≥0$ 接着列最初的表格（注意，最初的函数$Z$是用$x_1,x_2,x_3$表示的，所以此时$B=${$4,5,6$}： B $-10$ $-12$ $-12$ $0$ $0$ $0$ $0$ $4$ $1$ $2$ $2$ $1$ $0$ $0$ $20$ $5$ $2$ $1$ $2$ $0$ $1$ $0$ $20$ $6$ $2$ $2$ $1$ $0$ $0$ $1$ $20$ 根据我们先前所提到的，只要reduced costs为负我们就纳入选择，并在其中选择最小的index，所以此处的entering index为$1$ 接着根据minimum ratio test，我们发现有两个候选行可以作为pivot row：row 2和row 3（对应column 5和column 6）；注意，这意味着下一个BFS一定是退化的，因为存在和它优化程度相同的另一个BFS 再次根据small index rule，我们选择row $2$为pivot row，则$B(l)=5$，接下来迭代至下一个canonical form： row$2$中所有元素除以$2$ 消去其余三行中的pivot column（即column $2$） 于是我们迭代到下一个BFS： B $0$ $-7$ $-2$ $0$ $5$ $0$ $100$ $4$ $0$ $\\frac {3}{2}$ $1$ $1$ $-\\frac{1}{2}$ $0$ $10$ $1$ $1$ $\\frac{1}{2}$ $1$ $0$ $\\frac{1}{2}$ $0$ $10$ $6$ $0$ $1$ $-1$ $0$ $-1$ $1$ $0$ 我们选择column $2$为新的pivot column，根据MRT，pivot row为row $3$，但是我们遇到了ratio为$0$的情况，这意味着即使迭代到这个解，也不会使得当前解更优，不过只要我们一直沿用Bland’s rule，选择这个解也不会使循环发生 于是我们选择row $3$为pivot row，$B(l) = 6$，继续迭代： B $0$ $0$ $-9$ $0$ $-2$ $7$ $100$ $4$ $0$ $0$ $\\frac{5}{2}$ $1$ $1$ $-\\frac{3}{2}$ $10$ $1$ $1$ $0$ $\\frac{3}{2}$ $0$ $1$ $-\\frac{1}{2}$ $10$ $2$ $0$ $1$ $-1$ $0$ $-1$ $1$ $0$ 选择column $3$为pivot column，根据MRT，pivot row为row$1$ 选择row$1$为pivot row，$B(l)=4$，迭代： B $0$ $0$ $0$ $\\frac{18}{5}$ $\\frac{8}{5}$ $\\frac{8}{5}$ $136$ $3$ $0$ $0$ $1$ $\\frac{2}{5}$ $\\frac{2}{5}$ $-\\frac{3}{5}$ $4$ $1$ $1$ $0$ $0$ $-\\frac{3}{5}$ $\\frac{2}{5}$ $\\frac{2}{5}$ $4$ $2$ $0$ $1$ $0$ $\\frac{2}{5}$ $-\\frac{3}{5}$ $\\frac{2}{5}$ $4$ 所有reduced costs非负，所以该解即是最优解，最优解为$(4,4,4,0,0,0)$，最优值为$-136$ 在没有明显初始解时，我们将Tableau Method推广到Two-phase Method中 对最上一行的计算：（reduced costs） 对于basic part，reduced cost为0 对于nonbasic part，$\\hat c_j = c_j - c_B^TA_B^{-1}A_j = -1^TA_j$，由此我们可知，第$j$个reduced cost恰是该列所有其它元素之和。 同理，我们可知初始的objective value是所有其它RHS之和 在完成第一阶段的Tableau Method后，我们得到的是一个canonical form的表格，显然该表格并不能直接用作第二阶段Tableau Method的起始表格，我们还需要在中间加入一步转化： 为得到第二阶段的起始表格： 1.我们舍掉所有与辅助变量相关的column 2.我们将最上面一行中的reduced costs重新计算：$\\hat c_j = c_j - c_B^TA_B^{-1}A_j$ 3.如此得到的表格可作为我们进行第二阶段Tableau Method的起始表格 例： 假设我们第一阶段得到的表格如下： B $0$ $1$ $0$ $0$ $1$ $2$ $1$ $0$ $3$ $0$ $1$ $1$ $0$ $1$ $1$ $2$ $1$ $4$ $0$ $-1$ $0$ $1$ $1$ $-1$ $2$ $4$ $1$ $1$ $2$ $0$ $0$ $1$ $2$ $1$ $2$ 我们先更新reduced costs： $\\hat c^T = c^T - c_B^TA_B^{-1}A = c^T - c_B^T\\begin{pmatrix} 0 &amp; 1 &amp;1 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 1 \\ 1 &amp; 2 &amp; 0 &amp; 0 \\end{pmatrix}$ 注意到$A_B^{-1}A$是直接从Phase I的最终表格中读出来的 那么阶段二的初始表格为： B $0$ $\\hat c_2$ $0$ $0$ $-c_B^Tx_B$ $3$ $0$ $1$ $1$ $0$ $1$ $4$ $0$ $-1$ $0$ $1$ $4$ $1$ $1$ $2$ $0$ $0$ $2$ 接下来便可完成Simplex Tableau Method","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]Two-Phase Simplex Method and the Big-M Method","slug":"optimizationtwo-phase-simplex-method-and-the-big-m-method","date":"2025-09-27T07:50:55.000Z","updated":"2025-10-08T12:50:19.696Z","comments":true,"path":"2025/09/27/optimizationtwo-phase-simplex-method-and-the-big-m-method/","permalink":"http://example.com/2025/09/27/optimizationtwo-phase-simplex-method-and-the-big-m-method/","excerpt":"","text":"Finding an Initial BFS 在我们使用Simplex Method时，我们一定需要一个起点来应用Simplex Method，在先前的例子中，我们通常将所有不等式转化为等式（通过引入slack variable）后，解该方程组来得到一个初始可行解，但这种方式显然是不通用的，不妨引入如下例子： minimize $x_1+x_2+x_3$ subject to $x_1+2x_2+3x_3=3$ $-4x_2-9x_3=-5$ $3x_3+x_4=1$ $x≥0$ 在我们解该方程组时，我们以此方法得到的解是不满足$x≥0$的，这导致了我们不能通过该方法来寻找到一个基础的可行解。 而若我们想找到一个basis使得$x≥0$，我们需要多次检验$x_B = A_B^{-1}b$是否非负，这种朴素的遍历方式显然不是我们喜欢的，我们期望找到一个对于任何形式的LP都通用的，求初始BFS的方法。 Two-Phase Simplex Method Two-Phase Simplex Method作为对Simplex Method的优化版，唯一的差别就是加入了第一阶段的求初始BFS，第二阶段与我们之前所提到的迭代方法相同。 为了得到一个初始BFS，我们引入一个auxiliary problem， minimize$1^Ty$（decision variable为$x,y$） subject to $Ax+y=b$ $x,y≥0$ 若$A$为一个$n × m$的矩阵，那么$x$为一个$n × 1$的向量，$y$为一个$m×1$的向量 为了保证我们接下来操作的合法性，我们首先确保$b≥0$：若某行为负，则对其乘-1 对于该辅助问题，我们很容易就能得到一个初始解为$x=0,y=b ≥ 0$，我们之前的预处理操作使得该步的合法性得到保障；接下来我们便可以通过Simplex Method得到最优解。 引入定理： 原问题是feasible的，当且仅当辅助问题的optimal value为0 证：若原问题是feasible的，那么$Ax=b, x≥0$，参照auxiliary problem的$Ax+y=b$，我们得到$y=0$，那么$1^T Y$的最小值就是$0$. 若auxiliary problem的最小值为$0$，我们不妨设对应最优解为$\\hat x, \\hat y=0$，则$A\\hat x + \\hat y = A\\hat x = b，x≥0$，$\\hat x$的存在使得原问题的feasibility得到保证。 不妨考虑$\\hat x$在原问题中的含义：$\\hat x$正是原问题的一个BFS，于是我们通过求解auxiliary problem得到了original problem的一个初始BFS，由此BFS我们可以进入Simplex Method 那么，若auxiliary problem退化呢？ 我们在为原问题提供一个BFS时，注意到该BFS秩为$m$，而在auxiliary problem退化的情况下，该$\\hat x$的秩会小于$m$，这使得我们得到的$\\hat x$并不是一个严格的BFS 为了使得$\\hat x$的秩达到$m$，我们在矩阵$A$的剩余列（非基列）中选取一列，与$\\hat x$构成一个合格的BFS Big-M Method 考虑另一个auxiliary problem： minimize $c^Tx + M\\sum_{i=1}^m y_i$ subject to $Ax+y=b$ $x, y ≥ 0$ 该问题的初始BFS也为$x=0, y = b≥0$（同样进行预处理使得$b≥0$） 在用Simplex Method求解该问题时，我们假定$M$极大，那么： 若原问题feasible，则最优解为$\\hat y =0$且$\\hat y$中一定不含有basic indices（若$\\hat y$中存在basic indices，则会因为极大值$M$的约束使得该解不是最优解，只有不含basic indices的$\\hat y$才会作为Simplex Method的最终解）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]The Degenerate Case of Simplex Method","slug":"optimizationthe-degenerate-case-of-simplex-method","date":"2025-09-22T09:23:03.000Z","updated":"2025-10-08T12:50:13.306Z","comments":true,"path":"2025/09/22/optimizationthe-degenerate-case-of-simplex-method/","permalink":"http://example.com/2025/09/22/optimizationthe-degenerate-case-of-simplex-method/","excerpt":"","text":"Degeneracy 在上一节的讨论中，我们在考虑一个节点的相邻BFS时，默认只有两种情况 1.当前节点非最优，我们将跳跃到与之相邻的BFS中最优的那一个 2.当前节点是最优解，体现在它比所有相邻的BFS都更优 而在我们进行节点间跳跃时，我们将一个non-basic variable和一个basic variable互换；在我们先前的例子中，这个basic variable非零，使得我们能凭此来优化已有的解，那么如果存在为零的basic variable呢？ 存在为零的basic variable时，我们不妨考虑将这个为零的basic variable设为leaving variable的情况，那么交换前后，解的优劣性不变，而且交换后仍有可能会返回原来的节点，陷入循环。 这种情况下，我们之前的Simplex Method便不可用了。 于是当存在为0的basic variable时，我们将这种情况称为：Degenerate Case 注意到，Simlex Method的基本思路是可用的；在Degenerate Case中，不可用的仅仅是我们求局部最优解的算法。 也就是说，我们在处理Degenerate Case时，只需要得到一个新的、不会陷入自循环、同时能找到最优解的迭代方式即可。 Convergence in LP 在一般的Simplex Method运行的过程中，因为LP要么存在最优解，要么unbounded，所以我们在进行若干次的迭代后，一定会得到如下的结果之一： 该过程在最优解处停止 该LPunbounded，表现为$\\exists j-th$ basic direction $d$ with $\\overline{c_j} &lt; 0$ and $d ≥ 0$ 即该问题一定收敛到一个我们预想中的解 那么，在Degenerate Case中，我们也期望通过某种迭代方法，它能收敛到一个我们预想中的解。 由于LP仍然要么存在最优解，要么unbounded，所以抛开过程不看，从结果出发，Degenerate Case也仍然是收敛的，也就是说，这种迭代方法是存在的。 在这里我们直接给出这个迭代方法： Bland’s Rule： 若我们在选择entering basis和leaving basis时，遵循“最小下标”原则，那么在Simplex Method中不会再发生循环的情况。 entering basis选择：在所有正检验数中，选择下标最小的non-basic variable 该方法的证明在lec中没有给出，笔者的大概理解如下：即使最小下标是为0的basic variable,在下一次迭代中它不会再处在最小下标中，那么我们不会再从下一个节点回到当前节点，也就避免了循环的情况；而关于该方法的最优性，“最小下标”仅仅是在同时存在两个优化程度相同时的判断法则，前提仍然是选择最佳优化程度的解，所以最优性仍是得到保证的。 Reduced Cost in Degenerate Case 我们在研究非退化的Simplex Method时，提到若reduced costs vector $\\overline{c} &gt; 0$，那么当前的BFS$x$是最优的。这代表着：从当前节点出发，若每个方向都劣化了当前的解，那么代表这个节点是最优的。 那么当我们研究退化了的案例时，不难想到存在这样的情况：有若干相邻的节点，$i.e.$一条线段上的点都是最优解，那么考虑$\\overling{c}$的几何含义，那么这条线段的方向，正是可以“优化”当前解的方向，也就是说，在退化的案例下，即使是一个最优解，也可能存在$\\overline{c} &lt; 0$的情况 不过，在退化的情况下，只要我们一直应用simplex method，最后也会得到一个$\\overline{c}≥0$的解，只不过我们可能在这个解之前一些点就已经达到了最优解$x$，在simplex method的进一步迭代过程中，变化的只是basis而已。 而对于一个独立，非退化的解，我们能进一步保证，使其不同于退化解的是：它的$\\overline{c}$严格$&gt;0$，代表着它不会出现reduced cost为负的情况。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Optimization]Graphic Method and Simplex method","slug":"optimizationgraphic-method-and-simplex-method","date":"2025-09-13T12:32:15.000Z","updated":"2025-10-08T12:49:11.790Z","comments":true,"path":"2025/09/13/optimizationgraphic-method-and-simplex-method/","permalink":"http://example.com/2025/09/13/optimizationgraphic-method-and-simplex-method/","excerpt":"","text":"Graphic Method LP之所以叫线性方程组，正是因为它所含有的方程都是线性的，而简化到一个双变量的LP中时，我们不妨考虑这些约束条件在坐标系中的表现：作为线性函数，它们自然是方便分析且直观的。仍以第一节中提到的应用为例， 如图所示，我们能得到一个阴影区域，在该区域中的数对都是对此线性方程组的有效解。 我们不妨再关注一下与Objective Function对应的一组平行线：$3x_1+5x_2=c$ 在本例中，当该平行线不断向第一象限的右上角移动时，其相应的几何含义是Objective Function的值在不断变大。 自然，我们将上文所述的两个结论结合一下就能得到：在平行线不断移动的过程中，当其触碰到阴影区域的边界时，该交点便是此问题的最优解。 在使用Graphic Method时： 每个Decision Variable由一条轴表示，图示中的一个点代表一个解。 每个约束条件表现为一条直线的一侧，由若干条这种直线构成的多边形是该问题的可行域。 最优解在可行域和一组与Objective Function平行的直线簇的交点上。（有时会是一条直线） 补充概念： 当可行域为空，该LP是Infeasible的。 当Iso-line能一直移动而不到可行域的边界时，该LP是unbounded的。 可行域的极值点（多个约束条件的交点）我们称其为corner feasible point(CFP)，不难发现，一个最优解一定是一个CFP。 既然一个最优解一定是一个CFP，这显然会引入一个新的思考方式：如果我们把计算所有的CFP，取最大值的解，那么它便是全局最优解。不过，CFP的数量可能极多，这种思考方式是不适合人脑的。 不过，在分析一个CFP时，我们仍然有较为简便的方法来检验它是否是最优解： 值得注意的是，在该证明过程中，多边形的凸性质得到了运用，它保证了局部最优即是全局最优。 LP Geometry 在与线性方程组相关的一些解析几何方法中，我们引入如下定义： Polyhedron（多边形）是一个能写成如下形式的集合：${x\\in R^n: Ax ≥ b}$，$A$是一个$m × n$的矩阵，$b\\in R^m$ 注意到，这正是和LP标准形式写法相近的，再与Graphic Method相结合，我们能理解一个LP问题与一个解析几何中的多边形的强关联性。 Convex Set和Convex Combination：和之前DDA中所述定义一致，不再赘述。 Extreme Point：如名字所述，极值点。在LP问题中常表现为CFP，我们将在后文详细讲解如何求这些点。 Basic Solution： BS的定义看起来很莫名其妙，我们先大致描述一下BS是怎么样的一个特定解，BS存在的必要性会在Simplex method中体现。 BS提供了一组$x$，其中有$m个x_i$不为0，同时相应的，矩阵的column rank也大于等于m（注意，不是一定等于m），并且与这$m个x_i$对应的列都是独立的。 Basic Feasible Solution 若一个BS同时也满足$x≥0$，那么它就是一个BFS Extreme Point和BFS的关系：由一个LP标准形式构建的多边形，它的extreme point就是一个BFS，反之亦然。 Simplex Method 我们在分析Graphic Method的时候提到，遍历所有的CFP是不适合我们进行运算的，于是我们倾向于寻找一种优化遍历过程的算法，使得我们计算的次数得到减少。 回想起我们在Graphic Method中证明的性质，如果一个CFP没有比它更优的相邻CFP，那么该CFP即是此LP问题的最优解。 那么如果我们每次都从一个CFP迭代到与其相邻的最优CFP，这种过程的正确性是由此性质保证的。 于是我们便得到了一个用来求最优解的迭代算法： 从一个CFP开始 在该CFP的相邻CFP中寻找最优解 若该最优解优于当前CFP，迭代到该最优解 若该最优解劣于当前CFP，说明当前CFP即是全局最优解，迭代结束 重复上述过程 既然算法已经构建，我们接下来的目的就是将该过程代数化以便我们进行对LP问题的代数求解。 不妨先从slack variable的几何意义来切入： 回顾slack variable的引入背景，我们是在将一个不等式约束条件等式化的过程中引入的slack variable，如$3x_1+2x_2≤18$，我们引入$x_5$使得$3x_1+2x_2+x_5=18$且$x_5≥0$，在坐标系中考虑约束线$3x_1+2x_2=18$，不难发现$x_5$代表了解$(https://Arvin-Chaser.github.io/post-images/1757835220051.png) 进一步的，该图中的其余slack variable $x_3, x_4$的几何意义也是类似的，都表示了当前解到约束线的距离。 更一般化，Decision Variable$x_1,x_2$也可以看作是到对应坐标轴的距离，自此所有$x_i$的几何意义得到诠释 那么CFP和slack variable的关联在哪呢，这涉及到我们如何将其代数化 CFP是若干约束线的交点，这也意味着一个CFP的若干$x_i$为0，表示它是这些对应约束线的交点 值得注意的是，因为有$n$个Decision Variable，意味着该LP的图形是$n$维的，也就是说CFP是$n$个约束线的交点。所以当我们令$n$个$x_i$为0时，可以得到一个确定的解，该解正是一个CFP 回想起BS的定义，我们令$n$个$x_i$为0的过程，正是与BS的定义相互呼应的：在该过程中，共有$n+m$个变量，我们令$n$个变量为0，自然剩下$m$个不为0的变量，同时此时我们能得到一个唯一解，根据定义该解正是一个BFS 那么我们进一步拓展BS的定义，在求最优解的迭代过程中，我们称这些被我们设为0的变量为non-basic variables，不为0的变量我们称之为basic variables，如图 自此，我们解决了CFP的代数化，那么接下来我们要代数化的是“在一个CFP的相邻CFP中寻找最优解”的过程 - CFP是若干条约束线的交点，而两个CFP相邻则意味着它们在同一条约束线/平面上，换句话说，在$n$维的LP中，相邻的CFP具有$n-1$个相同且为0的slack variable，这使得它们被约束在同一个$n-1$维的空间上，而剩下1个不同的slack variable则决定了它们是相邻而非重合 - 明确了这一点，我们便知道了如何从一个CFP跳至一个相邻的CFP：交换一个non-basic variable和一个basic variable即可 - 不过，只知道如何从一个CFP跳至另一个相邻的CFP还是朴素的遍历，我们期望能有一种直接找到相邻的CFP中最优的那个解 考虑到LP中的所有方程都是线性的，所以在分析变量改变对Objective Function的影响时，我们可以直接考虑变量的系数：在LP的标准形式中，若我们仅仅用non-basic variable来表示Objective Function，那么将系数小的设为basic variable，是一定优于将系数大的设为basic variable的，这就是选择entering variable的最优方式 而为了选择leaving variable，我们直接在确定entering variable的基础上进行分析：由于entering variable一定是越大解越优，所以我们在不断扩大entering variable时，第一个因为它的扩大而减小到0的basic variable就是我们所求的leaving variable，因为只考虑entering variable就能确定最优解了，我们求leaving variable的过程实际上就是将entering variable最大化的过程 为达到方便寻找leaving variable和entering variable的目的，我们可以稍微改变式子的形式： 以上就是Simplex method，其整体过程总结如下： More general declaration by linear algebra 我们在前文明确了最优化的算法后，通过一个例子对最优解的求值过程大概体验了Simplex method的运行，接下来我们将用线性代数来对Simplex method的过程进行一个更rigorous的说明。 Starting Point 在每次迭代中，我们都会以一个starting point作为这次迭代的参照，那么对其代数化显然是代数化整个过程的关键一步。 对于一个Starting point，它显然是一个BFS，那么我们不妨令一个集合B包含所有的basic index，一个集合N包含所有的non-basic index。进一步的，$A_B$表示所有的basic column，$A_N$表示所有的non-basic column，于是$A$可以被重排为$[A_B,A_N]$，$x$对应重排为$[x_B;x_N]$，其中$x_N$均为0。 根据在一个标准问题中BFS的约束条件:$Ax=b$，我们得到：$x_B=A_B^{-1}b，x_N=0$. Finding a Neighbor BFS 线性代数化了BFS后，我们接下来考虑BFS的最优化过程，即不断寻找相邻的BFS中最优的那一个。 不妨考虑当我们选择$x_j$为entering variable的情况： 首先，因为后续需要考虑变化量，我们不妨假设相邻的BFS为$y$，且$y=x+\\theta d,\\theta ≥ 0$，这样我们就有了衡量变化量的方式：$\\theta$，而关于$d$，为了表现出non-basic variable中只有$x_j$变化，$d_j=1,d_i=0$，其中$i\\in N$，代表其它的non-baisc index。值得注意的是，这并不代表着$d_k=0, k \\in B$，因为$d_k$需要满足接下来的约束条件： 我们需要保证$y=x+\\theta d$仍是一个BFS，也就是说，$A(x+\\theta d)=b=Ax$，$Ad=0$ Basic Direction 我们在考虑跳向一个相邻的BFS时，从上文中我们不难得出，如果我们确定了entering variable的index，那么相应的$d$是确定的： 对于$d_N$，除了$d_j$其它都为0 对于$d_B$，$[A_B,A_N][d_B,d_N]^T=A_Bd_B+A_j=0$, $\\therefore d_B=-A_B^{-1}A_j$ 在$j$确定的情况下，$d$被确定为$[d_B;d_N]=[-A_B^{-1}A_j;0;…;1;…;0]$，其中1位于$d_N$的第$j$位 这样的$d$我们就称之为$j$th basic direction，因为它在我们确定entering $j$的情况下给出了对变化方向的指示，在这个方向上，$j$号元素得以成为basic variable，且$Ay=b$仍然满足。 值得注意的是，我们在这里同样可以保证$y ≥ 0$： 对于non-basic index$j$，$x_j = 0,d_j$为$1$或$0$，所以$x_j+\\theta d_j$仍然非负 对于basic variable$x_i$，因为$x_i＞0$，所以一定$\\exist \\theta s.t. x_i+\\theta d_i ≥ 0$ Reduced Costs 一般化的，我们希望也将objective function的变化值也用线性代数的形式来表示。 回忆起objective function的线性代数形式是$c^Tx$，那么我们与矩阵相似的，也将其分割：$c=[c_B;c_N]$ 延续我们已经讨论过的变化量$y=x+\\theta d$，$\\delta = \\theta d$，所以objective function的变化量为$\\theta c^T d$ 进一步的，若我们已经确定了$d$为$j$th basic direction，那么： $c^Td = c_j - c_B^TA_B^{-1}A_j$，我们将这个差值定义为$\\overline{c_j}$，称为reduced cost reduced cost是我们在确定变化方向$d$的情况下，用来衡量objective function变化的变量值。 当reduced cost为正时，表明方向$d_j$将增大objective function。 当reduced cost为负时，表明方向$d_j$将缩小objective function。 Stopping Criterion 与我们先前的最优化算法相同，只不过在此我们将结束条件转化为对reduced cost的约束： 令$\\overline{c} = [\\overline{c_1};…;\\overline{c_n}]$为reduced costs的对应向量，若$\\overline{c}≥0$，那么当前的$x$就是最优解。 Stepsize 我们在前文中提到，用$d$来表示确定entering index后$x$的移动方向，我们也凭此求得了objective function的变化衡量值reduced costs。但是明确的只是一个基本，或者说单位移动量，那么我们接下来要确定的就是到底移动了多少个单位量，变化的步调有多大。 回到最初我们引入$d$的情景：$y=x+\\theta d$，那么我们接下来需要考虑的就是$\\theta$的取值，也就是我们究竟能沿着$x_j$的方向迈多大的步子。 我们有基础的约束条件：$y = x+\\theta d≥ 0$ 同时我们想走的尽可能远，因为我们已经验证了，沿着这个方向一直走下去，解是不断优化的。 于是我们选择这样的Stepsize： $\\theta ^ * = max$ { $\\theta ≥ 0: x+\\theta d≥0$ } 不难发现，若$d≥0$，该问题是unbounded的 而对于某些$d_i &lt; 0, i \\in B$，那么我们便可以得到一个边界值$\\theta _ i$ = $-x_i/d_i$ 在所有满足条件的$\\theta _i$中取最小，该$\\theta _i$便满足所有条件，是最优解 即$\\theta ^ * = min -x_i/d_i$，其中$i \\in B,d_i &lt; 0$，值得注意的是，这意味着原本在basic index中的$i$，成为了leaving index，与$j$交换，自此我们确定了在迭代过程中所有需要知道的变量，我们便可以跳跃到下一个节点。 The Summary Part of Linear Algebra Form","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"[Discrete Math]Logic","slug":"discrete-mathlogic","date":"2025-09-06T10:31:36.000Z","updated":"2025-10-08T12:45:37.191Z","comments":true,"path":"2025/09/06/discrete-mathlogic/","permalink":"http://example.com/2025/09/06/discrete-mathlogic/","excerpt":"","text":"Using simple operators to construct other operators 讨论仅仅使用 ∧ ∨ ¬ 来表示其它已知输入和输入（Truth table）的运算 在复现一个新定义的运算时，我们有两种情况使得一个运算和一系列运算式 简单例：异或","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Discrete Math","slug":"Discrete-Math","permalink":"http://example.com/tags/Discrete-Math/"}]},{"title":"[Optimization]Linear Programming and Modeling","slug":"optimization","date":"2025-09-03T07:54:53.000Z","updated":"2025-10-19T16:10:56.442Z","comments":true,"path":"2025/09/03/optimization/","permalink":"http://example.com/2025/09/03/optimization/","excerpt":"","text":"Linear Programming Formulation)(LP Formulation) 当我们谈论求含多变量的线性函数的极值时，形如$max Z=3x_1+5x_2$的式子，若我们将变量名统一为某某字母+下标的形式，它们的表现方式往往让我们联想到简单矩阵相乘的结果。比如在该例中，$3x_1+5x2$可以看作$[3,5][x_1,x_2]^T$；这给我们以启发，将一些简单的最优化问题转化为对线性方程组的求解。 在此对$Linear Programming Formulation$进行定义，它包含两个部分： $objective function$ 非等式，是问题在模型化之后我们要求最值的函数 $constraints$ 若干个等式和不等式，约束了变量的范围 简单的例子： 当我们面对一个最优化问题时，最关键的是尝试设置合适的变量来表达已知的约束条件和将要求最值的函数。 在本例中，我们用$x_{ij}$表示从节点$S_i$到节点$D_j$所分配的转移量，那么所有的条件和我们需要求的函数都可以用$x_{ij}$来表示。 $objective function$: $min{Z} = 464x_{11}+513x_{12}+654x_{13}+867x_{14}+352x_{21}+416x_{22}+690x_{23}+791x_{24}+995x_{31}+682x_{32}+388x_{33}+685x_{34}$ 相应的，约束条件也可以用这些变量表示： $x_{11}+x_{12}+x_{13}+x_{14}=75$ $x_{21}+x_{22}+x_{23}+x_{24}=125$ $x_{31}+x_{32}+x_{33}+x_{34}=100$ $x_{11}+x_{21}+x_{31}=80$ $x_{12}+x_{22}+x_{32}=65$ $x_{13}+x_{23}+x_{33}=70$ $x_{14}+x_{24}+x_{34}=85$ $x_{ij}\\geq 0, i = 1, 2, 3, j = 1, 2, 3, 4$ 我们在前文中提到过，统一变量名和写成线性形式的约束条件是为了我们使用线性代数中的技巧来解决最优化的问题，那么自然，我们希望所有的LP问题都能归纳为一个统一的、适合求解的模板，以便我们通过$matlab$来得到最优解。那么从结果反过来想，可能存在的LP形式中，哪些形式是不适合我们用解线性方程组的方式来解答的？自然是不等式——当一些约束条件是不等式时，我们不能通过已有的变量将他们转化为形如$Ax=b$的线性方程形式，而若我们坚持将它们当作不等式或者变量的定义域来考虑，多个不等式的重叠可能造成解方程的困难。 但是，注意到，有一类不等式是可以作为定义域来考虑，且不会产生不同不等式的重叠的：$x_i\\geq c$，$c$为常量。在这类不等式中，一个不等式中只存在一个变量，如果所有的不等式都转化成这种形式，那么这些不等式之间显然不会存在相互影响的情况，这种形式是我们想要的。 那么我们为了这种便利的形式，接下来要做的就是将形如$x_1+x_2+x_3+x_4 \\leq 250$的不等式转化成等式和单元不等式的结合，我们通过添加元来实现这一点。 比如，我们想把$x_1+x_2+x_3+x_4 \\leq 250$转化，那么我们引入$x_5 = 250 - x_1-x_2-x_3-x_4$，则原不等式变为：$x_1+x_2+x_3+x_4+x_5 = 250$和$x_5 \\geq 0$，达到了我们的要求。 自此引入$LP$标准形式的定义： 值得注意的是，这里的$Ax=b$代表了所有约束等式的整合，$m$是添加元后所有元的数量，即$dim$。 同样的，为了方便表示，对于$x_1 \\leq 4$这样的单元但$c ≠ 0$的不等式，我们仍然将其进一步转化为$x_1+x_2=4$,$x_1 \\geq 0$, $x_2 \\geq 0$，这是与我们在标准形式中的x \\geq 0$是相呼应的。 当要求的是$objective function$的最大值时，我们变换为求负值的最小值，即转化为标准形式。 Modeling 所谓的建模，其实就是将实际问题转化为可求解/分析的数学形式的过程。 特别的，当我们讨论一个$max$或者$min$函数（将其作为$objective function$，如求一个$max$函数的最小值）时，它并不是一个方便计算或分析的形式，本部分将首先讨论对$max$和$min$函数的转化方式。 Maximizing the Minimum 直接给出一个例子：求$maxZ(x_1,x_2,x_3,x_4$， $where Z(x_1,x_2,x_3,x_4)=min{0.14x_1, 0.20x_2, 0.20x_3, 0.10x4}$（原题略去），那么我们的目的是寻找一系列与$Z=min{0.14x_1,0.20x_2,0.20x_3,0.10x_4}$等价的不等式组。 不难得出：$z\\leq 0.14x_1$, $z\\leq 0.20x_2$, $z\\leq 0.20x_3$, $z\\leq 0.10x_4$，接下来使用前面提到的技巧即将这些不等式转化为$LP$的标准形式即可求解 Minimizing the Maximum同理。 General Technique 在最优化中，一般化的建模（构建数学框架）的方法。 对于一个最优化问题，一般都可以写成这样的形式：(a)$minimize\\sum_{i=1}^{m} f_i(x)$ $s.t. x \\in \\Omega$ 而当我们引入另一个类似的最优化问题时：(b)$minimize\\sum_{i=1}^{m} t_i$ $s.t. x \\in \\Omega , f_i(x)\\leq t_i, \\forall i$，我们能得出如下的结论： 若$x^$是一个(a)的最优解，那么$(x^, f_1(x^),…, f_m(x^))$是(b)的一个最优解。 若$(x^, t^)$是一个(b)的最优解，那么$x^*$是一个(a)的最优解。 证明过程如下： 核心思路是：在两个最优化问题中分别构建大于等于和小于等于的关系，综合之后得到两个最优解是相等的关系，即这两个最优化问题共享最优解。 简单例： 在该例中，不方便处理的绝对值被转化成一个更加方便处理的新变量（新式子就是变量本身）和两个可转化为线性方程组的不等式。 复杂例： 该例中的思想是将分式尽可能的向线性形式转化，为了达到这个目的，使用较为复杂的换元，并将不等式用新元重载。 值得注意的是，在该Linear System中补充了一个新的等式$e^Ty+az=1$，补充该等式的原因是：该等式相当于构建了$x,y,z$的关系，从而保证一个$(y,z)$一定对应原问题中一个$x$，保证了两个问题的等价。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"}]},{"title":"河口湖……","slug":"he-kou-hu","date":"2025-08-04T05:46:06.000Z","updated":"2025-10-08T12:46:59.069Z","comments":true,"path":"2025/08/04/he-kou-hu/","permalink":"http://example.com/2025/08/04/he-kou-hu/","excerpt":"","text":"已经过去一年整了，我说的是那个河口湖的清晨。 去年的这个时间，新宿的一辆巴士载着我吱吱呀呀开向河口湖。不算新的车摇晃着思绪，只依稀记得窗外场景，从商业区到郊区的树木一帧一帧地迭代。我倒是清楚记得，在河口湖前停的最后一站，窗外有一座废弃的摩天轮。夕阳在草地上投下摩天轮的影子，仿佛二次元照进现实。 印象中，河口湖的车站大部分都是木制的，车站里随处可见的货架上摆放着富士山的明信片，价格自然是成本的数倍。 有点难绷，哪里的景点似乎都是一个德性。 入住酒店已经是傍晚，姜圣在附近找了一个烤肉店，记得这烤肉店颇有趣味，还赠送了一个挂饰，只是这挂饰已经不知所踪了。 放完行李，我们结伴沿着河口湖岸逆时针地走，正琢磨着富士山到底能在哪看到，内心忽而有感应，向左看去，首先映入眼帘的居然是三个并排的垃圾桶。 有趣的是，垃圾桶在日本是极其稀缺的，三个垃圾桶摆成一排居然也有些奇观的意味。 待眼睛适应了垃圾桶后那片浓郁的夜色，方才看清，在垃圾桶之后、越过一片栏杆之后的，正是富士山。 八月的富士山山腰没有雪，以至于我思索了一会眼前的到底是不是富士山，还是只是一座普通的山包。 下方是稀有的垃圾桶，上方是著名的富士山。 我自然不会怀疑垃圾桶是不是垃圾桶，但是我却没来由的质疑富士山是不是富士山。可能我心里下意识地认为富士山不会这样自然而然地就出现在三个垃圾桶的上面——现身的方式太戏剧性，太丑陋了。 但事实上，很多富士山正是和一群垃圾桶一起施施然出现的。 次日早晨，同行的两人还未醒来，我便没来由地独自往酒店楼下走去。或许我是想再给富士山一个现身的机会，如此我就可以当作她昨晚并没有在三个垃圾桶的上方出现过。总之，我迈着和昨晚相反的方向，顺时针沿着河口湖岸开始漫步。 出发时仍是阴天，微风缓缓拂过河口湖湖面，激起微波；彼时天刚亮，整个河口湖也尚未苏醒。我自得其乐地向前走，路旁是两三层的小房子，倒是和国内的乡下有几分相似。漆成红色的栏杆蜿蜒着指引方向，延伸向湖对岸。 记忆中，河口湖看起来并不大，路却不是严格沿着河岸向前的。等到视野中已不见河岸，我才意识到回头可能是更好的选择——此时同行的友人已经苏醒，催促我回去了。但我心中确乎存有怒气：该死的富士山，只愿意在三个垃圾桶上方现身，却不愿意以一个更优雅的姿态再度与我相见吗？于是我加快脚步，还是选择把顺时针的路走完。 下一个转角提供的视野也许就能看到富士山，我想。 待到我走到一座小桥上，回望整个河口湖，才意识到富士山其实一直都在视野之中，只不过飘絮般的云将山腰以上都挡住了。我不禁哑然失笑：原来富士山早就拒绝了我，是我自己迟钝地不愿发现罢了。 友人还在催，我也只能把顺时针的路走完。回头路太远也太苦涩了，我不愿再走一遭。 走过小桥，是一道长长的坡。从坡顶望去，车流自坡底汹涌而来。驻足片刻，我不知怎的突然很激动很有气力。富士山一直在那，我想，总有一天云会移开，山腰上也会再布满雪。湖畔的樱花也终将迎来她们的季节，我想，即使花开花谢，即使已经是下一代目。到那时我再来河口湖看富士山，我对自己说。 于是我逆着车流向坡底跑去，至少我没有走回头路，我有些骄傲。阳光从正前方洒下，略微灼目，我眯起眼睛，视野里一片模糊，好像正在冲向整个世界。 一年后的清晨，我又一次从晨星等到天明，开阔的视野里云缓缓飘过。自己感受着天气从微微凉到灼热，就仿佛和太阳一起重获新生。 发明时间的人大抵是个该死的天才。那么多一瞬的欢笑从此有了参照，那么多悲恸也自此有了刻印的依托。 我又想起河口湖的早晨，彼时我戴着廉价的耳机，沿着河口湖岸，一个人不要命地往前走。抬头是淡淡的云，阳光从缝隙投下，体感超过了暖和，却又不至于燥热。富士山被云挡住不见踪影，湖畔的樱花也不是盛开的季节。但我仍沿着红色的栏杆，穿过古旧的隧道，从坡顶逆着车流向下跑去。我知道总有一天我会看到云后的富士山，总有一个花季会让樱花盛开。 所以我还是选择往前走，没等待也没停留。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"[IELTS]Basic sentences and phrases","slug":"ieltsbasic-sentences-and-phrases","date":"2025-06-05T03:09:00.000Z","updated":"2025-10-08T12:47:17.640Z","comments":true,"path":"2025/06/05/ieltsbasic-sentences-and-phrases/","permalink":"http://example.com/2025/06/05/ieltsbasic-sentences-and-phrases/","excerpt":"","text":"住所和城市 It’s a close-knit community. close-knit 有凝聚力的 There are many leisure facilities in cities. leisure facilities 休闲设施，e.g. karaoke bars It’s a very walkable city. walkable 适合步行 学习 Children can gain knowledge and develop skills at school. gain knowledge, not learn knowledge Math skills can help to boost students’ money-management skills. 多使用boost和skill搭配 They work closely together to achieve their common goal. work closely together 紧密合作 Learning to play a musical instrument can help children improve concentration. improve concentration 增强注意力 Many employers look for candidates who can think out of the box. think out of the box 有创意地思考 其它 very approachable （老师）很好沟通的，平易近人的 a broad and balanced curriculum 广泛的、不偏科的学科设置 工作 They often work overtime. work overtime 加班 People who have foreign language skills have a competitive edge in the job market. have a competitive edge 拥有竞争优势 其它 down-to-earth 务实的 a nine-to-five job 一个“朝九晚五”的工作 a procrastinator 爱拖延的人，“拖延症患者” 合作、竞争 She is a team player. be a team player 擅长团队合作 Team members work closely together to achieve their common goal. 紧密合作 休闲、娱乐 It’s a good way to unwind. unwind 放松 It can help us recharge our batteries. recharge our batteries 让我们放松身心 亲情、友情 Children can lean important life skills by helping their parents. life skills 生活技能，而非living skills Nowadays, nuclear families are very common in cities. nuclear families 只有父母和孩子一起居住的小家庭； extended families 三四代人一起居住的大家庭 We can catch up with friends on social media. catch up with friends 和朋友聊近况 I can always count on them. count on sb. 信任某人 邻居、礼仪 Good neighbours make a house a home. 远亲不如近邻 Politeness is a virtue. 英国俗语 老人和儿童 He is adorable. 用adorable来形容儿童或者小动物可爱 He has an inquiring mind. 他的求知欲很强 He is young at heart young at heart心态年轻 其它 salt-and-pepper hair 花白的 头发 名人 They have paparazzi following them around. paparazzi 狗仔队（集合名词不加s） Some celebrities don’t use the products that they endorse. endorse products 代言产品 They are money-oriented. money-oriented 一切向钱看 She is a household fame. 她家喻户晓 其它 a self-made man 白手起家的人 a forward-looking leader 一位有远见的领袖 charisma 名人的魅力 autograph 亲笔签名 运动、户外运动、游戏 It can help us improve balance and coordination. 增强平衡协调能力 Swimming can boost endurance. 增强耐力 The park is an oasis in the city. 城市中的一片绿洲 We can get away from the hustle and bustle of city life. hustle and bustle of city life 都市生活的喧闹拥挤 It’s a must-see for nature lovers. a must-see 一个必去的地方 Birds chirp in the trees. chirp 鸣叫 动植物 短语 very agile 动作很敏捷的 social animals 群居动物 solitary animals 独来独往的动物 天气与气候 Some cities have four distinct seasons. 有些城市有分明的四季 It’s hot and humid in summer. 注意，hot和humid并不是反义词，humid的反义词是dry 交通和环境 Taking the underground is a good way to avoid traffic congestion. traffic congestion 交通堵塞（不可数），traffic jam是可数的 Carbon emissions from factories, cars and planes contribute to global warming. 旅行和假期 Some people prefer to travel light. travel light 轻装旅行 I catch up on sleep on holiday. 利用假期补觉 建筑 It’s well laid-out. 它的布局很合理 It is wrapped in glass. 它的外表都是玻璃 They have character. 它们有个性特色 City dwellers tend to lack a sense of belonging city dwellers 城市居民 购物和消费 短语 overspend 过度消费 flagship shop 旗舰店 boutique (buːˈtiːk) 小型的精品服饰店 designer clothes 名牌服装 membership card 会员卡 food court 美食街 pedestrian street 步行街 网络 短语 malware 恶意软件 cyber-crime 网络犯罪 绘画、摄影 短语 the color scheme 色彩搭配 vivid colors 鲜明的色彩 calm colors 平和的色彩 composition 构图 still life painting 静物画 portrait 人像 masterpiece 杰作 very photogenic （人）很上镜的 camera-shy 不爱照相的 snap some shots 快速地抓拍照片 classy 有品位的 电影、电视、歌曲 This film has a strong cast 这部电影的演员阵容强大 It has gripping action scenes. gripping 扣人心弦的 The special effects are amazing. special effects 特效 Their songs tend to be very catchy. catchy 容易记住，“上口” 政府 Governments need to increase funding for nature reserves. increase funding 增加资助 Governments need to take steps to help low-income families. 采取措施去帮助低收入家庭 (low-income family比poor family更礼貌)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/tags/IELTS/"}]},{"title":"[Linear Algebra]Linear Transformation","slug":"linear-algebralinear-transformation","date":"2025-04-21T13:14:16.000Z","updated":"2025-10-08T12:48:44.326Z","comments":true,"path":"2025/04/21/linear-algebralinear-transformation/","permalink":"http://example.com/2025/04/21/linear-algebralinear-transformation/","excerpt":"","text":"#1 Motivation of Linear Transformation 考虑对某个图形的放大及旋转： 对于一个初始坐标为$(x,y)$的变量 放大/旋转后坐标会如何变化？ 由该问题引入线性变换的概念 #2 Definition of Linear Transformation Mapping（映射） 注意描述集合和元素的对应关系时使用的箭头不一样 Linear Transformation： 线性变换的例子： #3 Checking Linear Transformation 考虑基础定义，并代入一些特殊值： 0是相当值得第一手验证的 直线 其实就是幸福定理 #4 Matrix of Linear Transformation 先以旋转为例： 在旋转的例子中旋转被转化成了乘一个矩阵，事实上这是能推广到所有线性变换的 而计算该矩阵的方式，我们先考虑一个全由单位向量组成的向量，它经过线性变换后转换的结果构成的矩阵正是符合结论的运算矩阵：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"http://example.com/tags/Linear-Algebra/"}]},{"title":"[Linear Algebra]Determinant","slug":"linear-algebra-determinant","date":"2025-04-20T19:37:31.000Z","updated":"2025-10-08T12:48:05.117Z","comments":true,"path":"2025/04/21/linear-algebra-determinant/","permalink":"http://example.com/2025/04/21/linear-algebra-determinant/","excerpt":"","text":"#1 Motivation of Determinant：Invertiblity Problem 在先前对矩阵是否可逆的讨论中，我们有如下命题，它们全部等价： 但很可惜的是，我们并没有一个确定的等量关系/判别方程来直接判断一个矩阵是否可逆。 为了完善这一体系，Determinant（行列式）应运而生。 不妨回顾一下在$2×2$的矩阵中，我们如何使用经验来判断它是否可逆的：对于矩阵 $$ \\begin{bmatrix} a&amp;b\\ c&amp;d\\ \\end{bmatrix} $$ 当且仅当$ad - bc ≠ 0$时，我们能判定它是可逆的。其实，这就是行列式的雏形。 行列式即为该运算方式的推广，$i.e.$ $det(A)≠0$, $iff$ $A$ $is$ $invertible.$ 还是回到$2×2$的矩阵中，在该矩阵中，$ad-bc$到底有什么含义呢？我们不妨和$Cauchy$一样，从几何的角度思考：$ad-bc$的形式与向量叉乘一致，这也就意味着它的数值与由向量$(a,c)和(b,d)$构成的平行四边形的面积相等： 值得注意的是，在上图中，我们将列向量$(a,c)和(b,d)$作为平行四边形的两条相邻的边，但实际上，行向量$(a,b)和(c,d)$同样可以作为决定平行四边形的两条边，它们所构成的平行四边形数值上也等于$ad-bc$。 接下来思考$ad-bc=0$所代表的含义：当$ad-bc=0$时，意味着上述平行四边形的面积为0，也就是说，向量$(a,c)和(b,d)$共线，二维的平行四边形迎来了向一条直线（一维）的退化： 不妨回顾一下我们先前对矩阵可逆性的讨论，我们曾提到：只有满秩的矩阵才可逆。而当$ad-bc$迎来退化，列向量共线时，也就意味着该矩阵不满秩，不可逆，这与我们$ad-bc=0$所导向的结果是一致的。自此，可逆性的逻辑迎来了一个小小的闭环，可喜可贺，可喜可贺。 那么，我们能否将二阶矩阵中的结论推广到更高阶的矩阵中呢？答案是肯定的。而在向更高阶推广时，行列式的几何意义也自然会发生变化：二阶时是面积，三阶时是体积，四阶时是四维几何体所占的四维空间的大小……自此，矩阵的阶数和所对应的几何维度，通过行列式达到了统一，可喜可贺，可喜可贺。 我们甚至可以反过来，用行列式定义$Volume$（广义上的）： #2 Properties of Determinant: Decomposition 对于行列式的分解，我们考虑两种基本运算：加法和（标量）乘法。 不妨先在$n=2$时进行一些小规模的运算，然后再尝试将它们推广到高阶矩阵中： 标量乘法：回顾在#1中我们对几何意义的判别，将 $$ \\begin{bmatrix} a&amp;b\\ c&amp;d\\ \\end{bmatrix} $$ 变为 $$ \\begin{bmatrix} ta&amp;tb\\ c&amp;d\\ \\end{bmatrix} $$ 可以理解为将构成平行四边形的一条边扩大到原来的$k$倍，面积（行列式的值）自然也扩大到原来的$k$倍。 加法，同样放到几何意义中处理： 在讨论更高维度时，我们并不能将行列式的几何意义很好的可视化，也就不能得出如上图所示如此具有说服力的证明，不过在经过大量的经验计算后，我们可以自信地宣称，这两条结论对于高维矩阵的行列式也是适用的。 #3 Block Diagonal and Zero-Row Terms $Corollary1$： 对引理1的理解：在行列式的几何意义中，每个行向量/列向量都是构成该几何体的一条从原点出发的边，那么当某条边变为0向量时，也就意味着整个几何体失去了一个维度，迎来了维度的退化。那么这个几何体在对应原维度中所占的空间自然同时会退化成0：联想二维图形之于三维，二维图形在三维中是缺少“高”这一维度的，我们也可以理解为二维图形是一个“高”维度为0的三维图形，它在三维中的体积自然是0。 $Corollary2$： 对引理2的理解：由行向量$(h, 0, 0)，(0, b2, b3)， (0, c2, c3)$构成的立体图形，自然是在以$(b3,c3), (b2, c2)$构成的平行四边形为底的基础上再乘一个大小为$h$的高得到。体积也就是$hdet(B)$。 在如上所述，对行列式进行加/乘法的分解及分块对角矩阵和0行向量的情况下，我们可以推广出三阶行列式的一般表达式……吗？ 如上图所示，我们发现为得到表达式，我们需要知道在交换列时，行列式会发生怎样的变化。 #4 Swapping Rows/Columns 先给出性质： 对该性质的解读：继续回到几何意义，我们不妨考虑一下，交换两个行对几何图形有什么影响？答案是没有影响。改变若干向量中的顺序并不会使得它们组成几何体所占空间大小发生改变，但是若代入到行列式中，行列式的数值却确实发生了改变，为解释这种改变，我们引入一个新的定义：有向面积。例如，如果我们规定顺时针旋转为正方向，那么在改变向量顺序的时候，也就意味着改变了这两个向量在形成平行四边形时所组成的二维图形面积的正负，从而改变了整个几何体所占空间的正负。 得到了该性质后，我们便能完成#3中对于三阶行列式一般式的推导： #5 Definition and Basic Properties of Determinant 在如上#1-#4讨论的内容中，我们默认我们已经了解行列式的计算方式，把它看作一个由行/列向量构成的几何体所占空间来计算，但回顾所有分析，我们并没有给出行列式的基础定义。不过在#4的最后一部分推导中，我们其实给出了一个方便定义的形式，于是给出如下定义： Example： 值得注意的是，在如上的定义中，我们确定第一行，然后在轮流删去每一列时用第一行作为余子式的系数，但这一选择显然不是唯一的。当我们进行任意的行交换时，显然每一行都能作为第一行，也就是说，任一行都能作为固定的参考行，由此归纳： 拉普拉斯展开比起最初的定义，显然是更方便我们计算一个特定行列式的，如例： 接下来考虑三种基本行运算对行列式大小的影响： 值得注意的是，因为$det(A^T) = det(A)$，所以能对行适用的运算同样适用于列。 #6 Advanced Properties of Determinant 回到最初引入行列式的目的，我们能在此对可逆性的体系进行最后的完善： 计算行列式的例子： 值得注意的是，此处我们选择$a_{13}$，顺着第三列进行拉普拉斯展开，这是因为第三列除了第一个元素都为0，故我们在计算行列式时仅有一项需要计算；同理，在计算行列式时，我们尽量选择0的数量多的行/列来进行拉普拉斯展开。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"http://example.com/tags/Linear-Algebra/"}]},{"title":"[Linear Algebra]Gram-Schmidt Process","slug":"linear-algebra-gram-schmidt-process","date":"2025-04-20T18:23:46.000Z","updated":"2025-10-08T12:48:19.333Z","comments":true,"path":"2025/04/21/linear-algebra-gram-schmidt-process/","permalink":"http://example.com/2025/04/21/linear-algebra-gram-schmidt-process/","excerpt":"","text":"#0 Key Questions 首先给出本节的核心问题及讨论要点： #1 Simple Cases：k=2 &amp; k=3 首先考虑两个向量的情况： 注意：此处的$p_1=(ux^Tv_1)v_1$，即为$p_1=&lt; v_1,u_2 &gt;v_1$, 是上一节中对投影的定义，意为$u_2$在$v_1$张成空间上的投影。 进一步的，考虑三个向量的情况： 与k=2相似的，此处的p2是u3在u1,u2张成空间上的投影，也就是u3在v1,v2张成空间上的投影。 #2 Formal Process 从#1中我们不难归纳出，在已知k个标准正交基，求第k+1个正交基时，我们先求$u_{k+1}$在$v_1,v_2,…,v_k$张成空间上的投影$p_k$, 那么 $\\frac{u_{k+1} - p_k}{||u_{k+1} - p_k||}$即为我们所求的$v_{k+1}$ 将整个过程用数学语言复述一遍，得到Gram-Schmidt Process的一般形式： 值得注意的是，该过程是用伪代码书写的，不难看出是一个迭代循环的过程。 Example： #3 Application 首先明确：GS Process是一个求一组标准正交基的过程，那么一组标准正交基有什么用呢？ 回顾上一节，我们知道：一组标准正交基可以用来求一个向量在它们张成空间上的投影。 自然，我们能想到：GS Process可以辅助我们求投影。 Example： 自此GS Process与Compute Projection建立起应有的联系。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"http://example.com/tags/Linear-Algebra/"}]},{"title":"[Linear Algebra]Orthogonal Basis and Orthogonal Matrix","slug":"linear-algebraorthogonal-basis-and-orthogonal-matrix","date":"2025-04-20T16:09:03.000Z","updated":"2025-10-08T12:48:55.906Z","comments":true,"path":"2025/04/21/linear-algebraorthogonal-basis-and-orthogonal-matrix/","permalink":"http://example.com/2025/04/21/linear-algebraorthogonal-basis-and-orthogonal-matrix/","excerpt":"","text":"#1 Orthogonal Set 直接给出定义： 进一步的，当Orthogonal Set中的每个向量模长均为1，该集合称为Orthonormal Set 如果已知一个Orthogonal Set，如何将其快速转化为一个Orthonormal Set呢： 将ui变为ui/||ui||即可 不妨思考，如果若干个向量之间两两都是orthogonal的，它们之间存在怎样的关系？ 联想到一个向量（力）的分解，一个向量在任意与它垂直的方向上是没有任何分量的，也就是说，这若干个向量中任意一个向量都不能拆分成剩下向量的复合。 也就是说，这若干个向量是linearly independent的。 #2 Orthogonal Basis and Orthogonal Matrix 回想一下基底，它们是若干个能张成空间、相互独立的向量，再结合一下#1中的Orthogonal Set，显然一个Orthogonal Set中的向量可以作为一组基底，再将Orthogonal Set优化为Orthonormal Set，我们称这一组向量为Orthonormal Basis，标准正交基。 值得注意的是，上一节中我们在解决normal equation时，Ax被我们看作了A的column space中的一个向量，若A是满秩的，那么A的若干列向量也是一组基底。我们不妨考虑，一个矩阵A的若干个列向量组成一个Orthogonal Set的情况；特别的，这种矩阵被定义为Orthogonal Matrix，正交矩阵： 引入一个命题及其证明： 用列向量表示原矩阵及其转置矩阵，十分好证。 正交矩阵的性质： (a)(b)©已证。 (d)：&lt; Qx, Qy &gt; = (Qx)(T)Qy = xT * QT * Q * y = xT * y = &lt; x, y&gt; (e)： ||Qx||² = &lt; Qx, Qx &gt;, ||x|| = &lt; x, x &gt;, 由(d)得两者相等 #3 Representation 回顾之前的知识，我们了解一组基底能够以一种唯一的方式表达出一个在该线性空间中的向量，求这种方式的过程也是解线性方程。 推广到Orthonormal Basis： 这个形式乍一看和标准的Σαiui大相径庭，下面给出两者等价的证明： 值得注意的是，uiTuj = 0 得到运用。 Example： #4 Projection 上一节中引入了投影的广义概念，本节讨论当存在标准正交基时，投影的表示方法。 注：整个空间是n维的，那么作为一个由k个标准正交基张成的子空间，S的 维度是k；而它的正交补空间维度是n-k，S的法向量，本例中的v-p便落在该正交补空间中。 拆分成p和v-p分别进行分解，此处的证明与#3中对等价证明的方法1相似。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"http://example.com/tags/Linear-Algebra/"}]},{"title":"[Linear Algebra]Least Squares Problem","slug":"linear-algebraleast-squares-problem","date":"2025-04-20T11:02:33.000Z","updated":"2025-10-08T12:48:30.520Z","comments":true,"path":"2025/04/20/linear-algebraleast-squares-problem/","permalink":"http://example.com/2025/04/20/linear-algebraleast-squares-problem/","excerpt":"","text":"#1 Example: Salary Prediction 与统计学中选择不同模型不同，线性代数中这类问题直接假设关系是线性的，从而将已知关系导向线性方程组。 不幸的是，只有两个未知数的线性关系在多方程的情况下很容易无解，如本例： 但是回顾一下统计学，我们能联想到，即使在统计学中出现符合线性模型的数据，也不是每一个数据点都落在直线上，而只是一个估计，更准确的说，残差分析是满足正态分布的。 那么在线性代数对线性模型的分析中，有这样留给我们估计的余地吗？有的兄弟，有的。 不妨模仿残差分析，分析对于一个独立的解，每个线性方程可能产生的error，即，在本例中： 接下来规定如何衡量误差大小，直接给出定义：使得norm(Ax-b)最小的解x是最合适的估计解。如在本例中：使得sqrt(ε1²+ε2²+ε3²)最小的解即为所求。 #2 Least Squares: Definition 推广#1中的衡量方式，即给出定义： *1：如上图，我们最小化向量的模来得出近似解。 *2：y是一个向量而非一个方程的固定解。 *3：特别的，当Ax=b存在解时，该解即为近似解，因为此时向量的模为0。 #3 Row Interpretation 不妨从行向量的角度理解该问题 首先，最小化||Ax-b||即等同于最小化||Ax-b||² 展开模长的平方，得： 值得注意的是，此处的每一项[ai(transpose) - bi]²正是对应共n个线性方程的n个残差之平方，也是我们在前文中回顾统计学中提到的概念。 #4 Linear Regression #5 Geometry Explanation and Projection 不妨再从Linear Space的角度思考一下||Ax-b||的其它含义：若把A看成若干个列向量，那么Ax就是一个由这若干个列向量所张成线性空间中的一个向量，而||Ax-b||便是一个向量b到向量Ax的距离，将其最小化这一问题其实也就是最小化向量b到向量Ax的距离，以容易想象的二次空间为例： 进一步推广，一般地： 注意：此处可将b和A理解为已知量，变量只有x 若以二次平面作理解，不难发现，当该距离取得最小值时，Ax即为向量b在张成平面上的投影。 推广，即得广义投影定义： #5 Finding Projection is Solving Equation 将投影的定义与Least Squares Problem相互对应，我们可以将Least Squares Problem转化成： 进行一系列运算及化简： 即： C(A)是A的Column Space","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"http://example.com/tags/Linear-Algebra/"}]},{"title":" [In Dialogue With Nature]2025 Spring Text 9 review","slug":"in-dialogue-with-nature2025-spring-text-9-review","date":"2025-04-15T17:37:08.000Z","updated":"2025-10-08T12:47:37.936Z","comments":true,"path":"2025/04/16/in-dialogue-with-nature2025-spring-text-9-review/","permalink":"http://example.com/2025/04/16/in-dialogue-with-nature2025-spring-text-9-review/","excerpt":"","text":"#1 The Enumeration Orders are orders in which the five elements were named in various ancient and mediaeval presentations of the subject. They were far from always being the same, but the four most important were as follows: i The Cosmogonic Order w F W M E ii The Mutual Production Order W F E M w iii The Mutual Conquest Order W M F w E iv The ‘Modern’ Order M W w F E where w is Water, W Wood, F Fire, M Metal and E Earth. 演化序：水、火、木、金、土。 相生序：木、火、土、金、水。 相克序：木、金、火、水、土。 现代序：金、木、水、火、土。 理解：演化序是元素被认为是形成的秩序。它从水开始，从而呼应了中国著作中反复强调的水是原始元素。相生序是一种要素相互产生的秩序；它以正确的顺序给出了季节，从春天的木开始，冬天的水结束（土对应于夏季和秋季之间的一个月）。相克秩序描述了一个系列，在这个系列中，每个元素都应该征服它的前身。现代序的意义模糊，然而这正是口语中流传下来的顺序。 #2 The Principle of Control was derived solely from the Mutual Conquest Order, and according to it a given process of conquest is said to be controlled by the element that conquers the conqueror. For example, Metal conquers Wood but Fire controls the process; Fire conquers Metal but Water controls the process and so on. 控制原则完全是从共同征服秩序中衍生出来的，根据它，一个给定的征服过程被称为由征服征服者的因素控制。例如，金征服了木，但火控制了过程；火征服金，但水控制过程，等等。 参考相克序，若顺序是ABC，则B征服A，但是C控制了过程。 有这样一种观念，即某物作用于他物而使他物毁灭，但在这样做的过程中，它本身也受到影响，从而使它自己发生变化或毁灭。化学反应因为反应产物的积累而停止就是一个例子。 #3 The second principle, the Principle of Masking, depends on both the MutualProduction and the Mutual Conquest Orders. It refers to the masking of a process of change by some other process which creates more of the material than is being destroyed, or makes it faster. Thus, Wood destroys (conquers) Earth, but Fire masks the process, since Fire will destroy Wood and make Earth (ash) at a greater rate than Wood can destroy Earth. 第二个原则，掩蔽原则，依赖于相生序和相克序。它指的是一个变化过程被另一个过程掩盖，这个过程创造的物质比被破坏的要多，或者使它更快。因此，木毁灭（征服）土，但火掩盖了这个过程，因为火会以比木毁灭土更快的速度毁灭木和土（灰烬）。 值得注意的是，这两个原则中都隐藏着很强的定量因素。 #4 符号相关性(The Symbolic Correlations) The Five Elements gradually came to be associated with every conceivable category of things in the universe that it was possible to classify in fives. 五行逐渐与宇宙中每一种可以想象到的、可以被分为五类的事物联系在一 起。但必须意识到，这只是一个选择。 这些相关性在古代也受到了一定的批评，因为它们能衍生出荒谬的事情：马与‘火’有关，鼠与‘水’有关。如果水真的能征服火，那么老鼠通常会攻击马并把它们赶走，这就更有说服力了。然后公鸡与‘玉’（金属）相连，野兔与‘毛’（木头）相连。如果金属真的能征服木头，为什么公鸡不吃兔子呢？ 然而，尽管有这样的批评，这些关联在一开始似乎对中国的科学思想是有帮助的。它们当然不比主宰欧洲中世纪思想的希腊元素理论更糟，只有当它们变得过于复杂和幻想，远离对自然的观察时，它们才真正有害。 沈括在加热赤泉时，硫酸铜析出，因此他提出水可以转变为金属——这是非同寻常的。 #5 命理学与科学思维(Numerology and Scientific Thinking) The seminal essence [ching] of the Yang is called shen. The germinal essence of the Yin is called ling. The shen and ling (vital forces) are the root of all living creatures; and the ancestors of [such high developments as] rites and music, human-heartedness and righteousness; and the makers of good and evil, as well as of social order and disorder.‘“When the Yin and Yang keep precisely to their proper positions, thenthere is quiet and peace. 阳的精粹叫做“神”。阴的生发精华被称为灵。神灵是万物之根；礼乐、仁义的祖先；是善与恶的制造者，也是社会秩序与混乱的制造者。当阴阳精确地保持在适当的位置时，就会有安静与和平。 “赤身裸体的人是圣人”，这是中国思想拒绝将人与自然、个人与社会分开的一个极好的例子；它同时也包含了一种观点：在最低级生物中起作用的基本力量与那些在更高层次上发展出人类社会和伦理生活的最高表现的基本力量是相同的。 Here we see that the Naturalists, or whoever it was who wrote it, were not only close observers of Nature, but also that their observations were fitted into a framework of number-mysticism. 自然主义者，不仅是自然的密切观察者，而且他们的观察也符合数字神秘主义的框架。 #6 两种基本力的理论(The Theory of the Two Fundamental Forces) Yin evokes the idea of cold and cloud,of rain, of femaleness, of that which is inside, dark like the underground chambers where ice is kept for summer use. Yang, on the other hand, evokes the idea of sunshine and warmth, of spring and summer months, of maleness and brightness. Yin and Yang also had more factual meanings: Yin the shady side of a mountain or valley, Yang the sunny side. 阴唤起了寒冷、云、雨、女性的概念，唤起了里面的东西，黑暗得像地下的房间，那里保存着夏天用的冰。另一方面，阳唤起了阳光和温暖，春夏季节，男性和光明的概念。阴阳也有更多的事实意义：阴指山或山谷的阴面，阳指阳面。 This splitting and re-splitting of two factors, with one dominant and one recessive, has parallels in modern scientific thinking, e.g. in genetics. In brief, some elements of the structure of the world as modern science sees it are foreshadowed in the speculation of the early Chinese philosophers. 这两个因素的分裂和再分裂，一个是显性的，一个是隐性的，在现代科学思维中有相似之处，比如遗传学。简而言之，现代科学所看到的世界结构的某些要素，在早期中国哲学家的思辨中就已经有了预兆。 #7 “联想”思维及其意义(‘Associative’Thinking and Its Significance) A study of primitive magic shows that this seems to have operated on the basis of two ‘laws’, the ‘law of similarity’ according to which like produces like, and the‘law of contagion’ whereby things that have once been in contact but are not so any longer, still continue to act upon one another. 对原始魔法的研究表明，这似乎是在两个“法则”的基础上运作的，一个是“相似法则”，根据“相似法则”，相似的东西会产生相似的东西；另一个是“传染法则”，根据“传染法则”，曾经接触过的东西，但不再接触了，仍然会继续相互作用。 现代学者称这种思维方式为“联想思维”或“协同思维”。它是一个通过联想和直觉运作的系统，它有自己的逻辑和自己的因果规律。它不仅是迷信，而且是一种按照自己的标准完全合理的思想形态，当然，它不同于现代科学的思维特征，现代科学强调的是外部原因。它不把自己的想法分成一系列的等级，而是以 一种模式并排排列。事物之间的相互影响不是通过机械原因，而是通过一种感应效应。 In the Chinese thought with which we are dealing, the key words are Order and Pattern; or one might almost say there is only one key-word, Organism, for certainly the symbolic correlations, the correspondences, the hexagrams of the I Ching, all formed part of one gigantic whole. Things behaved in particular ways not necessarily because of the prior actions of other things, but primarily because their position in the ever-changing cyclical universe was such that they were endowed with intrinsic natures which made such behaviour natural for them. If they did not behave in those particular ways they would lose their positions, and their relations to other things (which made them what they were) would alter and would turn them into something other than themselves. Their existence depended on the whole world-organism, and they reacted on one another by a kind of mysterious resonance. 在我们所讨论的中国思想中，关键词是秩序和格局；或者人们几乎可以说只有一个关键词，有机体，因为它们的《易经》中的符号关联、对应、卦象，都构成了一个巨大整体的一部分。事物以特定的方式表现并不一定是因为其他事物先前的行为，而主要是因为它们在不断变化的循环宇宙中的位置，即它们被赋予了内在的性质，这使得它们的这种行为对它们来说是自然的。如果他们不以这些特定的方式行事，他们就会失去自己的地位，他们与其他事物的关系（正是这些关系使他们成为现在的自己）就会改变，并将他们变成自己以外的东西。它们的存在依赖于整个世界有机体，它们以一种神秘的共鸣相互作用。 董仲舒以弦乐器的声学共振为例，证明了他的观点，即宇宙中属于同一类的事物相互共鸣或相互激发。宇宙的有机体是这样的：一切事物都各有其位置，并按照一个永恒的戏剧性循环而行动；如果任何东西错过了它的提示，它就会停止存在。 #8 With these thoughts in mind, we are driven to the conclusion that there are two ways of advancing from primitive truth. One was the way taken by some of the Greeks: to refine the ideas of causation in such a way that one ended up with a mechanical explanation of the universe, just as Democritus did with his atoms. The other way is to systematise the universe of things and events into a structural pattern which conditioned all the mutual influences of its different parts. On the Greek world-view, if a particle of matter occupied a particular place at a particular time, it was because another particle had pushed it there. On the other view, the particle’s behaviour was governed by the fact that it was taking its place in a ‘field of force’ alongside other particles that are similarly responsive: causation here is not ‘responsive’ but ‘environmental’. 有了这些思想，我们就会得出这样的结论：从原始真理出发，有两种前进的道路。一种是一些希腊人所采用的方式：以这样一种方式来完善因果关系的概念，最终得到宇宙的机械解释，就像德谟克利特对他的原子所做的那样。另一种方法是将事物和事件的宇宙系统化，形成一种结构模式，这种模式制约了宇宙中不同部分的相互影响。在希腊人的世界观中，如果一个物质粒子在特定的时间占据了特定的位置，那是因为另一个粒子把它推到了那里。另一种观点认为，粒子的行为是由这样一个事实决定的，即它与其他同样有反应的粒子一起出现在一个“力场”中：这里的因果关系不是“反应”，而是“环境”。 中国传统的宇宙观和现代科学普遍接受的两种宇宙观之间的对比，在它们对数字的使用上表现得非常明显。当然，大量值得信赖的数学是在中国完成的，正如我们将看到的，但问题的关键是中国人将数字神秘主义或数字命理学与他们的联想思维联系起来。 宇宙是一个巨大的有机体，有时这个部分，有时那个部分，在任何时候都起主导作用，所有的部分都以一种完全自由的相互服务的方式合作。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"与自然对话","slug":"与自然对话","permalink":"http://example.com/tags/%E4%B8%8E%E8%87%AA%E7%84%B6%E5%AF%B9%E8%AF%9D/"}]},{"title":"[In Dialogue With Nature]2025 Spring Text 8 review","slug":"in-dialogue-with-nature2025-spring-text-8-review","date":"2025-04-15T14:50:28.000Z","updated":"2025-10-08T12:47:39.394Z","comments":true,"path":"2025/04/15/in-dialogue-with-nature2025-spring-text-8-review/","permalink":"http://example.com/2025/04/15/in-dialogue-with-nature2025-spring-text-8-review/","excerpt":"","text":"#1 That new theory maintained his earlier distinction between conscious and unconscious mental functions, but it added three interacting psychic agencies: the ego, the id, and the superego. Freud saw consciousness as the surface of the mental apparatus. Much From of our mental function is submerged below that surface, Freud argued, just as the bulk of an iceberg is submerged below the surface of the ocean. The deeper a mental function lies below the surface, the less accessible it is to consciousness. Psychoanalysis provided a way of digging down to the buried mental strata, the preconscious and the unconscious components of the personality.（人格的前意识和无意识成分） 弗洛伊德认为意识是精神器官的表面，大部分心理功能都如同冰山的主体一样淹没在水面之下，隐藏的越深意识就越难以触及：这是弗洛伊德早期对有意识和无意识心理功能的区分，在引入自我本我超我之后，产生了新的模型。 #2 According to Freud’s structural theory, the ego (the “I,” or autobiographical self) is the executive agency, and it has both a conscious and an unconscious component. The conscious component is in direct contact with the external world through the sensory apparatus for sight, sound, and touch; it is concerned with perception, reasoning, the planning of action, and the experiencing of pleasure and pain. The unconscious component of the ego is concerned with psychological defenses (repression, denial, sublimation), the mechanisms whereby the ego inhibits, channels, and redirects both the sexual and the aggressive instinctual drives of the id, the second psychic agency. ego（自我）作为执行机构，既有有意识的成分，也有无意识的成分，意识部分通过感觉器官与外界直接接触，与计划、快乐和痛苦的体验有关；无意识部分与心理防御有关，是自我抑制，引导和重定向本我和攻击性本能驱动的机制。所以本我可以看作第二种心理代理。 #3 The id (the “it”), a term that Freud borrowed from Friedrich Nietszche, is totally unconscious. It is not governed by logic or by reality but by the hedonistic principle of seeking pleasure and avoiding pain. The id, according to Freud, represents the primitive mind of the infant and is the only mental structure present at birth. The superego, the third governor, is the unconscious moral agency, the embodiment of our aspirations. 本我(id)是完全无意识的，不受逻辑或现实的支配，受寻求快乐和避免痛苦的享乐主义原则支配。弗洛伊德认为，本我代表婴儿的原始心智，是出生时唯一存在的心智结构。 而超我(superego)文中并没有作出较为详细的解释，只指出**它是无意识的道德力量，是我们愿望的化身。**自然可以看出自我本我超我的最明显区别是其中有意识和无意识的组成：自我两者兼备，本我完全无意识，超我也是完全无意识的。 #4 At its core, consciousness in people, is an awareness of self, an awareness of being aware. Consciousness thus refers to our ability not simply to experience pleasure and pain but to attend to and reflect upon those experiences, and to do so in the context of our immediate lives and our life history. Conscious attention allows us to shut out extraneous experiences and focus on the critical event that confronts us, be it pleasure or pain. 人的意识的核心是对自我的意识，即对被意识的意识。有意识的关注让我们把无关的经历拒之门外，把注意力集中在我们面临的关键事件上，无论是快乐抑或痛苦。 #5 When Crick first entered biology, after World War II, two great questions were thought to be beyond the capacities of science to answer: What distinguishes the living from the nonliving world? And what is the biological nature of consciousness? 克里克（发现DNA结构的克里克）进入生物学领域时，整个生物学科面临着两个问题：是什么区分了生命和非生命的世界？意识的生物学本质是什么？前者被DNA的发现所解答。但后者一直缺乏一个有效的研究手段。 Indeed, some scientists and philosophers of mind continue to find consciousness so inscrutable that they fear it can never be explained in physical terms. How can a biological system, a biological machine, they ask, feel anything? Even more doubtful, how can it think about itself? 一些科学家和心灵哲学家认为意识十分不可思议，他们发问：一个生物系统，一个生物机器，怎么能有感觉呢？它怎么能想到自己呢？这些问题并不新鲜，公元前五世纪，Hippocrates和Plato就提出过这些问题，他们认为所有的心理过程(mental process)都来自大脑，而我们能够思考我们自己和我们会死的身体(mortal body)的唯一原因是我们有一个非物质的、不朽的灵魂(a soul that is immaterial and immortal)。该观念在十三世纪由St. Thomas Aquinas加以阐述，他认为意识也有神圣的起源(of dinive origin)。 In the seventeenth century, René Descartes developed the idea that human beings have a dual nature: they have a body, which is made up of material substance, and a mind, which derives from the spiritual nature of the soul. The soul receives signals from the body and can influence its actions but is itself made up of an immaterial substance that is unique to human beings. Descartes’ thinking gave rise to the view that actions like eating and walking, as well as sensory perception, appetites, passions, and even simple forms of learning, are all mediated by the brain and can be studied scientifically. Mind, however, is sacred and as such is not a proper subject of science. 笛卡尔提出了人类具有双重本性的观点：他们有一个由物质构成的身体，还有一个来自灵魂的精神本质的心灵。灵魂接受来自身体的信号，可以影响身体的行为，但本身由一种非物质组成，而这种物质是人类特有的。也就是说像吃饭走路这样的行为，以及感官知觉、食欲、激情、简单的学习形式都是由大脑调节的，可以科学地研究。 统一地说，这是二元论(dualism)，认为灵魂是不朽的，独立于大脑之外。 #6 Today, most philosophers of mind agree that what we call consciousness derives from the physical brain, but some disagree with Crick as to whether it can ever be approached scientifically. A few, such as Colin McGinn, believe thatconsciousness simply cannot be studied, because the architecture of the brain poses limitations on human cognitive capacities. In McGinn’s view, the human mind may simply be incapable of solving certain problems. At the other extreme, philosophers such as Daniel Dennett deny that there is any problem at all. Dennett argues, much as neurologist John Hughlings Jackson did a century earlier, that consciousness is not a distinct operation of the brain; rather, it is the combined result of the computational workings of higher-order areas of the brain concerned with later stages of information processing. 今天，大多数心灵哲学家都同意我们所说的意识来自物理大脑，但有些人不 同意克里克关于是否可以科学地接近它的观点。Colin McGinn 等少数人认为意 识根本无法被研究，因为大脑的结构限制了人类的认知能力。在 McGinn 看来， 人类的思维可能只是无法解决某些问题。在另一个极端，哲学家如丹尼尔·丹尼 特根本否认存在任何问题。丹尼特认为，就像一个世纪前神经学家约翰·休林 斯·杰克逊（John Hughlings Jackson）所做的那样，意识并不是大脑的一种独 特的操作；相反，它是大脑中与信息处理后期阶段有关的高阶区域的计算工作的 综合结果。 #7 Searle and Nagel ascribe two characteristics to the conscious state: unity and subjectivity. The unitary nature of consciousness refers to the fact that our experiences come to us as a unified whole. All of the various sensory modalities are melded into a single, coherent, conscious experience. Searle 和 Nagel 认为意识状态有两个特征：统一性和主体性。意识的统一性指的是我们的经验作为一个统一的整体出现在我们面前。所有不同的感觉模式都融合成一个单一的、连贯的、有意识的体验。 也就是说视觉嗅觉等不同感官体验是汇聚在一起，作为一个整体而形成感知、体验的。 Subjectivity, the second characteristic of conscious awareness, poses the more formidable scientific challenge. Each of us experiences a world of private and unique sensations that is much more real to us than the experiences of others. We experience our own ideas, moods, and sensations directly, whereas we can only appreciate another person’s experience indirectly, by observing or hearing about it. 主观性是意识的第二个特征，它对科学提出了更为艰巨的挑战。我们每个人 都经历着一个私人和独特的感觉世界，对我们来说，这比别人的经历更真实。我 们直接体验自己的想法、情绪和感觉，而我们只能通过观察或倾听间接地欣赏他 人的体验。 这意味着，我们无法直观地从主观的角度体会别人的感受，只能通过他人的描述进行较为超脱、客观的了解。 意识体验的统一性意味着，绑定过程一定以某种方式连接并整合了大脑中所有这些独立的区域 内格尔认为，在科学研究中例行进行的缩减没有问题。生物科学可以很容易地解释一种特定物质的性质是如何从构成它的分子的客观性质中产生的。科学所缺乏的是解释主观属性(subjective properties)（意识）如何从客体属性(properties of objects)（相互联系的神经细胞）中产生的规则。 #8 In Crick and Koch’s last paper, they focused on the claustrum, a sheet of brain tissue that is located below the cerebral cortex, as the site that mediates unity of experience. Little is known about the claustrum except that it connects to and exchanges information with almost all of the sensory and motor regions of the cortex as well as the amygdala, which plays an important role in emotion. Crick and Koch compare the claustrum to the conductor of an orchestra. Indeed, the neuroanatomical connections of the claustrum meet the requirements of a conductor; it can bind together and coordinate the various brain regions necessary for the unity of conscious awareness. 在Crick和Koch的最后一篇论文中，他们把重点放在了**屏状体(claustrum)**上，这是一 块位于大脑皮层下方的脑组织，是调节体验统一性的部位。我们对屏状体知之甚 少，只知道它与皮层几乎所有的感觉和运动区域以及杏仁核相连，并与杏仁核交 换信息，杏仁核在情绪中起着重要作用。Crick和Koch把屏状体比作管弦乐队的 指挥。的确，屏状体的神经解剖学连接符合导体的要求；它可以结合并协调大脑 的各个区域，这是统一意识意识所必需的。 Crick认为claustrum是注意力的焦点，是将任何感知的不同组成部分联系在一起的地方，因为这个微笑的结构连接到大脑的许多区域。 #9 Using MRI, Eric Lumer and his colleagues at University College, London have identified the frontal and parietal areas of the cortex as the regions of the brain that become active when a person’s conscious attention switches from one image to another. These two regions have a special role in focusing conscious attention on objects in space. In turn, the prefrontal and posterior parietal regions of the cortex seem to relay the decision regarding which image is to be enhanced to the visual system, which then brings the image into consciousness. Indeed, people with damage to the prefrontal cortex have difficulty switching from one image to the other in situations of binocular rivalry. Crick and Koch might argue that the frontal and parietal areas of the cortex are recruited by the claustrum, which switches attention from one eye to the other and unifies the image presented to conscious awareness by each eye. 利用核磁共振成像技术，伦敦大学学院的埃里克·卢默和他的同事们确定了大脑皮层的额叶和顶叶区域，当一个人有意识的注意力从一个图像切换到另一个图像时，这些区域就会变得活跃。这两个区域在将有意识的注意力集中到空间中的物体上方面起着特殊的作用。反过来，大脑皮层的前额叶和后顶叶区域似乎将关于哪幅图像需要增强的决定传递给视觉系统，然后视觉系统将图像带入意识。事实上，前额叶皮层受损的人在双眼竞争的情况下很难从一个图像切换到另一个图像。克里克和科赫可能会认为，大脑皮层的额叶和顶叶区域是由屏状体负责的，它将注意力从一只眼睛转移到另一只眼睛，并将每只眼睛呈现的图像统一为有意 识的意识。 #10 进一步的问题是：无意识的情绪感知是如何以及在哪里被加工的？ Unconscious perception of fearful faces activated the basolateral nucleus. 对恐惧面孔的无意识感知激活了基底外侧核。 Conscious perception of fearful faces, in contrast, activated the dorsal region of the amygdala, which contains the central nucleus, and it did so regardless of a person’s background anxiety. 相比之下，对恐惧面孔的有意识感知激活了杏仁核的背侧区域，该区域包含中央核，而且不管 一个人的背景焦虑如何，它都会这样做。 这表明，在情感领域，刺激可以被无意识和有意识地感知。其次，这些研究从生物学角度证实了无意识情绪的精神分析思想的重要性。 这也与弗洛伊德的观点相符合：精神病理学起源于无意识层面的冲突，如果有意识地面对冲突的根源，它可以被调节。 #11 自由意志的本质：既然弗洛伊德发现了心灵决定论——我们的认知和情感生活的大部分都是无意识的——那么还有什么留给个人选择和行动自由的呢？ A critical set of experiments on this question was carried out in 1983 by Benjamin Libet at the University of California, San Francisco. Libet used as his starting point a discovery made by the German neuroscientist Hans Kornhuber. In his study, Kornhuber asked volunteers to move their right index finger. He then measured this voluntary movement with a strain gauge while at the same time recording the electrical activity of the brain by means of an electrode on the skull. After hundreds of trials, Kornhuber found that, invariably, each movement was preceded by a little blip in the electrical record from the brain, a spark of free will! He called this potential in the brain the “readiness potential” and found that it occurred 1 second before the voluntary movement. 从该实验中可以得知，仅仅通过观察大脑的电活动，就可以在一个人真正意识到自己做某事之前预测他将要做什么。 这一发现引起了心灵哲学家的疑问：如果选择在我们决定行动之前就在大脑中决定了，那么自由意志在哪里呢？难道我们对行动的意愿只是一种幻觉，是对已经发生的事情事后的一种合理化吗？或者是自由做出的选择，但不是有意识的？ Whatever the reasons for the delay between decision and awareness, Libet’s findings also raise the moral question: How can one be held esponsible for decisions that are made without conscious awareness? The psychologists Richard Gregory and Vilayanur Ramachandran have drawn strict limits on that argument. They point out that “our conscious mind may not have free will, but it does have free won’t.” Michael Gazzaniga, one of the pioneers in the development of cognitive neuroscience and a member of the American Council of Bioethics, has added, “Brains are automatic, but people are free.” One cannot infer the sum total of neural activity simply by looking at a few neural circuits in the brain. 心理学家 Richard Gregory 和Vilayanur Ramachandran 对这种观点进行了严格的限制。他们指出：“我们的意识可能没有自由意志，但它确实有自由意志。”认知神经科学发展的先驱之一、美国生物伦理委员会成员迈克尔·加扎尼加（Michael Gazzaniga）补充说：“大脑是自动的，但人是自由的。”人们不能仅仅通过观察大脑中的几个神经回路就推断出神经活动的总和。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"与自然对话","slug":"与自然对话","permalink":"http://example.com/tags/%E4%B8%8E%E8%87%AA%E7%84%B6%E5%AF%B9%E8%AF%9D/"}]},{"title":"拼凑的断音","slug":"pin-cou-de-duan-yin","date":"2025-04-07T17:03:59.000Z","updated":"2025-10-08T12:51:00.180Z","comments":true,"path":"2025/04/08/pin-cou-de-duan-yin/","permalink":"http://example.com/2025/04/08/pin-cou-de-duan-yin/","excerpt":"","text":"前些日子为了完成所谓ITE的作业，去学了一下怎么调ai翻唱。自己上手后才发现这玩意学习成本意外的低。 说是意外其实也是情理之中，现在的作品似乎都有着高度集成的模板，开发的过程竟被略去了。 确实是好事，尽管我并不喜欢。 研究完这东西，我向同学炫耀起来——我一向是热衷于行这事的，尽管我脑子里明白很蠢。 我一直爱干一些我早就知道很蠢的事。 各种意义上。 学会这东西，自然是要试用一番的。我于是向同学问起来，你想听啥歌？ 拼凑的断音，他说。 我愣了一下，拼凑的断音吗。 原因自然不难想，毕竟我各种游戏id都叫拼凑的断音，但是距离上次我把它下意识的当作一个歌名，已经过去很久了。 到底过去多久了呢？ 高中吗。还是更久远的从前？我好像记不清了。 高中时我很喜欢说，回忆过去就像在时间的河里刻舟求剑，但这次的回忆好像已经不在如今我所处的河流中了。 我这里暂时没这首歌音源，我和同学这样说，也算是做了个交代。 我把音源和过去的记忆一起弄丢了，其实我本来想这样说。但是这次我没说，毕竟这言辞有些蠢过头了，我还是不想做这种事的。 不过话说回来，认为这样说很蠢是不是本身也是一件蠢的有些过头的事呢。 我爱干一些我知道很蠢的事，我早就说过。 回到正题，我还是去搜了拼凑的断音这首歌。搜了才发现，居然已经是快十年前的歌了。我慢慢听了一遍，竟又回想起一些细节——似乎我听的最频繁的版本不是初音本家，而是一个唱见cover的，似是叫东京某某。 键入搜索，却没有这号人物翻唱的拼凑的断音。 难道这又是我错乱的记忆里拼凑出的一个若有若无的人物？ 不是。至少这次不是，我能肯定。 我甚至还记得这个cover的封面是唱见的虚拟形象，白发红瞳，侧着身。她在我分辨率低的可怜的老mp3模糊地出现过无数次，这反倒是很清晰的记忆了。 我于是单纯搜索这个唱见本人，这次有了结果——似乎这人塌房了云云。无怪乎搜不到这名唱见的翻唱了。略微浏览了几个网页，似乎是堕入邪教之类。 什么鬼。 我是不信教的，但是我一直很羡慕坚定相信这些诸如往生之类的人。如果我能毫不怀疑的相信有来生云云，说不定也不会活成这样了。 外公还在的时候，有一晚我和他躺在一张床的上下铺上。说来巧合，也大概便是八九岁，刚好是拼凑的断音发行的年份左右吧。当晚我突然想到自己有一天会失去一切感官，不再能感知世界上的一切，没人可说无话可说，突然嚎啕大哭起来。 外公被我吵醒，得知缘由后并没说话。只是在黑暗中等待我哭完，随后帮我把被子重新盖上，一夜无话。 外公一贯是习惯在凌晨，我们家都起来前独自一人回老家去的，所以我小时候经常见不到外公离去的场景。但有一回我在醒来之后对我妈说的话我还记得， 虽然外公走了，但是我的心已经说了再见。 唉。 后来外公走了，我却到今天都还没说一句真正的再见。 亲人的离世只是你和他之间的错过，你去到他家里他却刚好在公交车上奔波;你去到公交车上他却已经换乘了的士。你们永远存在同一个世界里，只是永远会错过。 初中时候听周杰伦，他唱 但偏偏/雨渐渐/把距离吹的好远/还要多久/我才能在你身边/但故事的最后你好像还是说了/拜拜 彼时我自作聪明的发问，为什么是拜拜不是再见，毕竟再见是和偏见远边押韵的。 后来我才明白，拜拜可以是再也不见。偏偏是欢快的两个音节，拼凑起来却是那么残酷的含义。 还是说回拼凑的断音吧。 虽然是小学时候就有的歌，但听的最多的时候竟然已经是初三和高一。 说来可笑，那时候对日语仍然是一窍不通，所以歌听到耳朵里也就是听个调，但我还是听了那么多遍。可能是因为这首歌没有任何预兆的人声开头，也可能是结尾的戛然而止，又或者是间奏前的咳嗽声让我感觉真实。过去的心理已经不可找寻，我只能任由记忆将它修饰的愈发美好。 但记忆里与这首歌相关的场景确乎还在脑海中盘旋，我记得我体育课时躺在夏日的树荫下，校服盖着头听着这首歌;也记得熄灯后的寝室里，等生活老师查完寝后拿出mp3在一遍遍循环中睡去。 那时候未来模糊的很美好，雨淋在身上都是快乐的依仗。 现在我又看着拼凑的断音的歌词， たﾞから いっそ いっそ いなくなれ 干脆 干脆 消失掉吧 変わらない このままたﾞし 如此永不改变 たふﾞん きっと きっと 所以一定一定 なんてことない 并非什么要紧事来 少し寂しくなるけとﾞ 只是会变得有点寂寞而已 ねえ いいの？ いいの 呐这样好吗？这样好吗 捨てちゃうよ 我要放弃了哦？ 気つﾞかない? またﾞ気つﾞかないなら 既然这样都依然不被你发现的话 …そっか そっか 好きなのは ･･･这样啊 这样啊 喜欢上你 最初から 仆たﾞけ 从一开始 只是我一厢情愿 消失的是过去，一厢情愿单相思的是理想。而至于寂寞，即使是一点点寂寞我也不能忍受，于是我尝试活成别人不讨厌的样子，高声应和着别人的论调，只是卑微希望着不被抛弃而已。 又想起初三时看到网友写的好想做嘉然小姐的狗啊。依稀记得里面写到，可是我只是一只老鼠。 哈哈，他没提到的是，其实老鼠也分三六九等。 有的老鼠能吃到奶酪，而我一直没爬出臭水沟。 不过乐观点，至少老鼠还是十二生肖。 致那段不够美好的曾经，甜美、单纯，而且管不住自己。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"Gridea与Github Pages远程连接失效的解决方法","slug":"gridea-yu-github-pages-yuan-cheng-lian-jie-shi-xiao-de-jie-jue-fang-fa","date":"2025-01-30T08:12:44.000Z","updated":"2025-10-08T12:46:36.896Z","comments":true,"path":"2025/01/30/gridea-yu-github-pages-yuan-cheng-lian-jie-shi-xiao-de-jie-jue-fang-fa/","permalink":"http://example.com/2025/01/30/gridea-yu-github-pages-yuan-cheng-lian-jie-shi-xiao-de-jie-jue-fang-fa/","excerpt":"","text":"一、前言 笔者若干天没有管理博客后，在心血来潮检查repositories时，惊奇地发现Gridea和Github Pages之间的远程连接居然断掉了。（连接逃げる） 第一时间，笔者下意识认为是repositories的token过期了，于是重新整了一个，但是Gridea上仍然显示远程连接断开，令人疑惑。几经鼓捣后，笔者终于找到了问题所在，本文将大概介绍一下笔者的解决方法。 二、出现连接问题的根本原因 当repositories中的token过期时，Gridea会失去对repositories的访问权限，就像用一把旧钥匙去开一个新锁，不能同步是自然的。这也是笔者下意识认为问题所在之处 遇到这种情况很方便，就按照当初设置Gridea时一样重新申请一个token就行了。 但是有一点要补充，在若干次更新前，github设置token的页面添加了一个Fine-grained tokens，这个玩意笔者感觉像是一个测试版本，而且好像和经典的token编辑方式不太一样（？）总之，和之前一样，在Github-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens里选Tokens(classic)就行了，这就是我们熟知的token版本。 如果重新申请token后，或者我们的token没有设置过期时间Gridea还是连接不上repositories，那么就大概率是网络的问题。笔者在网上看到各种相当前沿的解决方法，比如每次写完避开同步，而使用github client本地克隆repositories去上传等等。但是笔者之前有一个repositories就是在本地上传时崩了，所以没敢用这种方法。（是真的会崩，所以强烈建议大家别在本地强制push，不过崩的原因笔者不知道）那么我们就回到这个问题本身：网络问题。说白了，无非是我们的个人电脑和在github中的repositories连接没有构建好，而本地上传就是直接避开这个连接过程，用github客户端检测到的库冲突来强制push。在已知强制push可能会爆炸的情况下，我们能不能尝试直接解决网络问题，稳定个人电脑和github中repositories的连接情况呢？答案是肯定的。 三、解决方法 大家都知道，电脑打开网页时，会先行在本地的hosts文件中检测是否有匹配的网站，如果匹配，那么就用hosts中预设的IP来为域名指定好地址；如果不匹配，那么浏览器会将网址提交到DNS服务器来进行IP地址解析。DNS解析的这个过程，便是可能会出现连接情况异常的来源。那么很显然，只要我们绕过DNS，直接预设好github的IP地址，就能达到快速打开网页的目的，从而最大幅度的优化本地与github repositories之间的连接情况。笔者在这里直接把ping github IP地址的网站贴出来：Here 笔者自己是选择了一个霓虹的IP地址，延迟只有惊人的8ms（ 四、详细过程 在库中按如下路径找到hosts（无后缀名！！！）：C:\\Windows\\System32\\drivers\\etc 注意：系统文件直接搜索搜不到，慢慢找罢。 提供管理员权限，修改hosts（在属性-&gt;安全-&gt;高级里提供权限）。或者有更加简单易懂的方法：先将hosts复制出该路径，在用记事本修改新hosts副本后，再将其复制回该路径下替换，全程不用提供管理员权限。是您的不二之选 五、结语 对Gridea与Github Pages远程连接失效的解决方法，研究的同时还能复习电脑打开网页的底层逻辑，可喜可贺，可喜可贺。 又：本文有一个若只彩蛋","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"软件","slug":"软件","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"JAVA中的Exception","slug":"java-zhong-de-exception","date":"2025-01-15T09:24:14.000Z","updated":"2025-10-08T12:47:50.371Z","comments":true,"path":"2025/01/15/java-zhong-de-exception/","permalink":"http://example.com/2025/01/15/java-zhong-de-exception/","excerpt":"","text":"一、前言 笔者在学习java的过程中经常见到一些throws Exception或者类似的语句；在初学java，阅读一些代码框架时，throws Exception的语句常常被笔者认为是不必要，甚至莫名其妙 的，本文将解答笔者本人曾经的疑惑，系统性地介绍java中exception的含义。 二、异常的分类 先贴个图 由图我们大致了解到，在throwable这个类下，主要有三种异常： error checked exception unchecked exception error 最常见的error包括但不限于栈溢出，堆溢出，jvm预设的空间不足等等，在oj上评测时表现为runtime error memory limit exceed等，由于此类异常不需要我们在程序中对其进行精确的评估与预处理，本文不深入探讨。其实是笔者不会 unchecked exception 非受控异常，又被称为RuntimeException，顾名思义，是在running a programme 时出现的异常，这类异常可以在不使用try...catch模块的前提下进行处理，例如0作除数的异常，我们可以直接加入对分母是否为0的判断来用顺序结构解决这个异常。 checked exception 受控异常，当编译器检测到这一类异常时，会要求编写者对其使用try...catch模块进行预处理，或者用throws声明让上一级调用来处理。在不处理的情况下编译器将不予通过编译，这也是其名称中checked的含义。而这一类异常的预处理，是笔者接下来想探讨与说明的重要内容。 三、受控异常的处理 throws抛出处理 先贴一段人尽皆知的代码： public static void main(String[] args) throws Exception { 作为java中常见的主函数声明，笔者在初学时，并不能明白其与public static void main(String[] args){的区别。这也带来了疑惑：throws Exception在java中扮演了怎样的角色？这也就是本文开头所提到的问题。 先说结论：throws作为对出现的异常问题的一种声明处理，将该异常抛出处理，而“抛出”这个有些不负责任词汇的含义在于： 谁调用这个函数，谁负责处理该异常 函数的第一人称叙述大概是这样的： 我知道自己可能会出现异常，但是是另一个主体调用的我，那么这个主体应该提前预料到会有这样的后果，于是我把这个异常扔给调用者来处理，自己直接撒手不管，好不自在！ 但是不难想到，如果每个函数都秉持着这样一种“我不干别人干”的想法，将异常扔给上一级，所有的异常都会积累在主函数里，那么作为权力链顶端的主函数，它如果在声明中也加上throws Exception，是怎样的后果呢？ 答案很显然： 天塌下来有高个子顶着，但是异常堆起来，主函数也想润了。 于是，在主函数中加上throws Exception的声明就真真正正的是throw away了，所有的Exception都会被扔到虚空中，无人在意，程序照样进行。 try...catch预处理 不管怎么说，如果我们碰到所有Exception都大笔一挥，throw away的话，当程序出现Exception的时候，我们不能精准地判断究竟是出现了哪种Exception，也就不能进一步进行调试。更重要的是，一直throw away显得我们很不负责任。 所以，当知道可能出现的Exception类型时，try...catch模块的预处理就显得尤为重要。 完整的try...catch模块格式如下： 12345678910try&#123;&#125; catch (Exceptiontype1 e1) &#123;&#125; catch (Exceptiontype2 e2) &#123;&#125; finally &#123;&#125; try中包含了可能产生Exception的代码块 catch可以有一个或多个，catch中是需要捕获的异常及其类型 当try中代码出现了在下方catch中预先声明的Exception时，try中的代码会停止顺序处理，直接跳转到对应的catch模块中进一步运行 finally代表了无论出不出现异常，都要执行的部分，可以与try单独使用 123456try&#123; code1 &#125; finally&#123; code2 &#125; 上述代码块意为：若code1中无异常产生，则执行code1和code2，若code1中产生异常，则立刻停止执行code1，执行code2 try...catch实例： 1234567try &#123; int tmp1 = 1, tmp2 = 0; int ans = tmp1 / tmp2; System.out.println(ans);&#125; catch(ArithmeticException arithmeticException) &#123; System.out.println(&quot;divided by 0&quot;);&#125; 运行结果如下： divided by 0 不难看出，在line 3产生Exception后，line 4便不再执行，跳转到line 6执行。 注：即使在catch模块中存在return 语句，finally模块也会照样执行，只有当catch模块中出现用System.exit(0) 来退出 JVM 的情况，finally模块中的代码才不会被执行 四、拓展 捕获顺序 在对Exception进行catch时，其实还存在捕获顺序这一潜规则： 一般按照从小到大的顺序，先捕获子异常，再捕获父异常。 为何会存在这样的要求呢？ 在执行对Exception的catch时，被catch的Exception并不会仍然存在，而是会被抓走，这就意味着在接下来的捕获过程中，该异常不会再引起其它catch模块的执行，而我们在对程序进行调试时，目标自然是尽可能完整地了解所产生异常的类型，如果先捕获父异常，再捕获子异常，那么我们只会得到产生了父异常这一不够精确的结果，不符合我们的预期。 换句话说： 在抓捕Exception这一犯罪团伙时，我们先击垮那些下属，最后再对高层一网打尽，从而抽丝剥茧，辨析清楚整个Exception的分布方式。 自定义异常 自定义异常通常也分为自定义受控异常和自定义非受控异常，用来在自己产出的代码中传递错误信息。 自定义受控异常 12345678910class MyCheckedException extends Exception &#123; public MyCheckedException() &#123; //调用父类的默认构造函数 &#125; public MyCheckedException(String s) &#123; //手动调用父类的构造方法 &#125;&#125; 自定义非受控异常 12345678910class MyRuntimeException extends RuntimeException &#123; public MyRuntimeException() &#123; //调用父类的默认构造函数 &#125; public MyRuntimeException(String s) &#123; //手动调用父类的构造方法 &#125;&#125; 使用自定义异常示例 1234567891011121314151617181920212223242526272829public class MyExceptionClass &#123; public static void main(String[] args) &#123; test1(); test2(); &#125; static void test1() &#123; try &#123; func1(1, 0); &#125; catch (MyCheckedException e) &#123; System.out.println(e.getMessage()); &#125; &#125; static void test2() &#123; func2(1, 0); &#125; static void func1(int num1, int num2) throws MyCheckedException &#123; if(num2 == 0) &#123; throw new MyCheckedException(&quot;Checked Exception: denominator can&#x27;t be 0&quot;); &#125; System.out.println(num1 / num2); &#125; static void func2(int num1, int num2) &#123; if(num2 == 0) &#123; throw new MyRuntimeException(&quot;Unchecked Exception: denominator can&#x27;t be 0&quot;); &#125; System.out.println(num1 / num2); &#125;&#125; 运行结果： Checked Exception: denominator can't be 0 Unchecked Exception: denominator can't be 0 五、结语 本文对笔者自己在初学java时对throws Exception产生的疑惑进行了一个相对深层次的探究与发散，与读者共勉。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"Departure","slug":"departure","date":"2025-01-10T16:45:40.000Z","updated":"2025-10-08T12:44:41.292Z","comments":true,"path":"2025/01/11/departure/","permalink":"http://example.com/2025/01/11/departure/","excerpt":"","text":"For the brand new life. $2025.1.11$ He can win almost everything one more time if he wants to. $2025.9.28$","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/tags/%E6%9D%82%E8%B0%88/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"Optimization","slug":"Optimization","permalink":"http://example.com/tags/Optimization/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Discrete Math","slug":"Discrete-Math","permalink":"http://example.com/tags/Discrete-Math/"},{"name":"Number Theory","slug":"Number-Theory","permalink":"http://example.com/tags/Number-Theory/"},{"name":"杂谈","slug":"杂谈","permalink":"http://example.com/tags/%E6%9D%82%E8%B0%88/"},{"name":"IELTS","slug":"IELTS","permalink":"http://example.com/tags/IELTS/"},{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"http://example.com/tags/Linear-Algebra/"},{"name":"与自然对话","slug":"与自然对话","permalink":"http://example.com/tags/%E4%B8%8E%E8%87%AA%E7%84%B6%E5%AF%B9%E8%AF%9D/"},{"name":"软件","slug":"软件","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]}